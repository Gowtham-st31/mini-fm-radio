<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Admin - Mini FM Radio</title>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
<style>
  :root{--bg1:#ff7e5f;--bg2:#feb47b;--card:#ffffff;}
  body{font-family:Inter,Arial,Helvetica,sans-serif;margin:0;background:linear-gradient(135deg,var(--bg1),var(--bg2));color:#222;min-height:100vh;display:flex;align-items:center;justify-content:center;padding:24px;}
  .card{background:var(--card);width:100%;max-width:920px;border-radius:14px;box-shadow:0 10px 30px rgba(0,0,0,0.15);padding:24px;}
  h1{margin:0 0 10px;font-size:28px;color:#333;}
  .controls{display:flex;gap:12px;flex-wrap:wrap;margin:16px 0;}
  .controls button, .controls input[type="file"]{padding:10px 14px;border-radius:10px;border:none;cursor:pointer;font-weight:600}
  .btn-primary{background:#3b82f6;color:#fff}
  .btn-danger{background:#ef4444;color:#fff}
  .btn-accent{background:#10b981;color:#fff}
  .small{font-size:13px;color:#555;margin-top:8px}
  .row{display:flex;gap:12px;align-items:center;margin-top:12px;}
  label{display:flex;gap:8px;align-items:center;font-weight:600}
  .status{margin-top:14px;padding:10px;border-radius:8px;background:#f3f4f6;color:#111}
  audio{width:100%;margin-top:12px;border-radius:8px}
  .modes{display:flex;gap:12px;align-items:center}
  .hint{font-size:13px;color:#666;margin-top:8px}
</style>
</head>
<body>
  <div class="card">
    <h1>üéôÔ∏è Admin Broadcast Control</h1>

    <div class="modes" style="margin-top:8px;">
      <label><input type="radio" name="mode" value="mic" checked> Mic only</label>
      <label><input type="radio" name="mode" value="song"> Song only</label>
      <label><input type="radio" name="mode" value="mix"> Mix (Mic + Song)</label>
    </div>

    <div class="row">
      <input id="songFile" type="file" accept="audio/*">
      <div class="hint">Choose a local MP3/OGG file for "Song" or "Mix".</div>
    </div>

    <div class="controls">
      <button id="startBroadcast" class="btn-primary">‚ñ∂ Start Broadcast</button>
      <button id="stopBroadcast" class="btn-danger" disabled>‚ñ† Stop Broadcast</button>
      <button id="toggleMic" class="btn-accent">Mute Mic</button>
    </div>

      <div id="stats">
    <p>Status: <span id="status">Ready</span></p>
    <p>Render Health: <span id="render-health">Checking...</span></p>
  </div>

    <div style="margin-top:16px">
      <label style="font-weight:700">Local preview:</label>
      <audio id="preview" controls></audio>
    </div>

    <p class="small">Tip: For system audio (Spotify/YouTube) include it by routing output to a virtual audio device (VB-Cable, VoiceMeeter, BlackHole) and select that as a source in browser or use "Song" with a local file.</p>
  </div>

<script>
(async function(){
  const startBtn = document.getElementById('startBroadcast');
  const stopBtn = document.getElementById('stopBroadcast');
  const toggleMicBtn = document.getElementById('toggleMic');
  const statusText = document.getElementById('statusText');
  const preview = document.getElementById('preview');
  const songFileInput = document.getElementById('songFile');

  let ws;
  let mediaRecorder;
  let currentStream = null;
  let micStream = null;
  let songEl = null;
  let songStream = null;
  let mixedStream = null;
  let micEnabled = true;

  function logStatus(s){ statusText.textContent = s; }

  function ensureWS(){
    if (ws && ws.readyState === WebSocket.OPEN) return Promise.resolve();
    return new Promise((res,rej)=>{
      const protocol = window.location.protocol === "https:" ? "wss" : "ws";
      ws = new WebSocket(`${protocol}://${window.location.host}`);
      ws.binaryType = 'blob'; // Changed from 'arraybuffer' to 'blob' for MediaRecorder compatibility
      ws.onopen = ()=> { console.log('WS open'); res(); };
      ws.onerror = (e)=> { console.error('WS error', e); rej(e); };
      ws.onclose = ()=> console.log('WS closed');
    });
  }

  async function getMicStream(){
    if (micStream) return micStream;
    micStream = await navigator.mediaDevices.getUserMedia({ audio: true });
    return micStream;
  }

  function createSongElement(file){
    if (songEl){
      songEl.pause();
      URL.revokeObjectURL(songEl.src);
      songEl.remove();
      songEl = null;
    }
    songEl = document.createElement('audio');
    songEl.controls = false;
    songEl.src = URL.createObjectURL(file);
    songEl.crossOrigin = "anonymous";
    document.body.appendChild(songEl);
    return songEl;
  }

  function stopAllStreams(){
    if (mediaRecorder && mediaRecorder.state !== 'inactive') mediaRecorder.stop();
    if (micStream) micStream.getTracks().forEach(t => t.stop());
    if (songStream) songStream.getTracks().forEach(t => t.stop());
    if (mixedStream) mixedStream.getTracks().forEach(t => t.stop());
    micStream = null; songStream = null; mixedStream = null;
    if (songEl) { songEl.pause(); songEl.remove(); songEl = null; }
    currentStream = null;
  }

  function startMediaRecorder(stream){
    mediaRecorder = new MediaRecorder(stream, { mimeType: 'audio/webm;codecs=opus' });
    mediaRecorder.ondataavailable = (evt) => {
      if (evt.data && evt.data.size > 0 && ws && ws.readyState === WebSocket.OPEN) {
        console.log(`üé§ Sending audio chunk: ${evt.data.size} bytes`);
        ws.send(evt.data);
      } else {
        console.log(`‚ö†Ô∏è Cannot send data - size: ${evt.data?.size}, WS state: ${ws?.readyState}`);
      }
    };
    mediaRecorder.start(250);
  }

  async function startBroadcast(){
    try { await ensureWS(); }
    catch (e){ alert("WebSocket connection failed. Make sure server is running."); return; }

    const mode = document.querySelector('input[name="mode"]:checked').value;
    stopAllStreams();

    if (mode === 'mic') {
      const mic = await getMicStream();
      currentStream = mic;
      preview.srcObject = mic;
      preview.muted = true;
      preview.play().catch(()=>{});
      startMediaRecorder(currentStream);
      logStatus('Broadcasting (Mic only)');
    } else if (mode === 'song') {
      const file = songFileInput.files[0];
      if (!file) { alert('Please choose a song file first'); return; }
      songEl = createSongElement(file);
      songStream = songEl.captureStream ? songEl.captureStream() : songEl.mozCaptureStream();
      currentStream = songStream;
      preview.srcObject = null;
      preview.src = songEl.src;
      preview.play().catch(()=>{});
      songEl.play();
      setTimeout(()=> startMediaRecorder(currentStream), 300);
      logStatus('Broadcasting (Song only)');
    } else if (mode === 'mix') {
      const file = songFileInput.files[0];
      if (!file) { alert('Please choose a song file for mixing'); return; }
      const mic = await getMicStream();
      songEl = createSongElement(file);
      const ac = new (window.AudioContext || window.webkitAudioContext)();
      const micSource = ac.createMediaStreamSource(mic);
      const songSource = ac.createMediaElementSource(songEl);
      const dest = ac.createMediaStreamDestination();
      micSource.connect(dest);
      songSource.connect(dest);
      mixedStream = dest.stream;
      currentStream = mixedStream;
      preview.srcObject = mixedStream;
      preview.muted = true;
      preview.play().catch(()=>{});
      songEl.play();
      startMediaRecorder(currentStream);
      logStatus('Broadcasting (Mic + Song mix)');
    }

    startBtn.disabled = true;
    stopBtn.disabled = false;
  }

  function stopBroadcast(){
    stopAllStreams();
    if (ws && ws.readyState === WebSocket.OPEN) { try { ws.close(); } catch(e) {} ws = null; }
    preview.pause();
    preview.srcObject = null;
    startBtn.disabled = false;
    stopBtn.disabled = true;
    logStatus('Idle');
  }

  function toggleMic(){
    if (!micStream) { alert('Mic not active. Start mic broadcast first or choose Mix mode.'); return; }
    micEnabled = !micEnabled;
    micStream.getAudioTracks().forEach(t => t.enabled = micEnabled);
    toggleMicBtn.textContent = micEnabled ? 'Mute Mic' : 'Unmute Mic';
  }

  startBtn.addEventListener('click', startBroadcast);
  stopBtn.addEventListener('click', stopBroadcast);
  toggleMicBtn.addEventListener('click', toggleMic);

  window.addEventListener('beforeunload', () => {
    stopAllStreams();
    if (ws) try { ws.close(); } catch(e){}
  });
})();
</script>
</body>
</html>
