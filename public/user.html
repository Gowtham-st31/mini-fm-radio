



<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>FM Radio - HD PCM Player</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      text-align: center;
      padding: 20px;
      margin: 0;
      min-height: 100vh;
    }
    
    .container {
      max-width: 600px;
      margin: 0 auto;
      background: rgba(255, 255, 255, 0.1);
      padding: 40px;
      border-radius: 20px;
      backdrop-filter: blur(10px);
    }
    
    h1 {
      color: #ff6b35;
      margin-bottom: 30px;
      font-size: 2.5rem;
    }
    
    .status {
      padding: 20px;
      margin: 20px 0;
      background: rgba(0, 0, 0, 0.3);
      border-radius: 15px;
      font-size: 1.2rem;
      min-height: 60px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    .btn {
      background: linear-gradient(45deg, #ff6b35, #f7931e);
      color: white;
      border: none;
      padding: 18px 35px;
      font-size: 1.2rem;
      border-radius: 30px;
      cursor: pointer;
      margin: 15px;
      min-width: 200px;
      font-weight: 600;
    }
    
    .btn:disabled {
      background: #666;
      cursor: not-allowed;
    }
    
    .btn.stop {
      background: linear-gradient(45deg, #e74c3c, #c0392b);
    }
    
    .audio-section {
      margin: 30px 0;
      padding: 25px;
      background: rgba(0, 0, 0, 0.2);
      border-radius: 15px;
      display: none;
    }
    
    .play-controls {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 25px;
      margin: 25px 0;
    }
    
    .play-btn {
      background: linear-gradient(45deg, #27ae60, #2ecc71);
      color: white;
      border: none;
      width: 80px;
      height: 80px;
      border-radius: 50%;
      font-size: 2rem;
      cursor: pointer;
    }
    
    .volume-control {
      display: flex;
      align-items: center;
      gap: 10px;
    }
    
    .volume-slider {
      width: 120px;
      height: 6px;
      border-radius: 3px;
      background: rgba(255, 255, 255, 0.3);
      outline: none;
    }
    
    .stats {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 15px;
      margin: 25px 0;
    }
    
    .stat {
      background: rgba(0, 0, 0, 0.3);
      padding: 20px 15px;
      border-radius: 12px;
      text-align: center;
    }
    
    .stat-value {
      font-size: 1.8rem;
      font-weight: bold;
      color: #ff6b35;
      margin-bottom: 8px;
    }
    
    .stat-label {
      font-size: 0.9rem;
      opacity: 0.8;
    }
    
    .success {
      background: rgba(46, 204, 113, 0.3) !important;
      color: #2ecc71 !important;
    }
    
    .error {
      background: rgba(231, 76, 60, 0.3) !important;
      color: #e74c3c !important;
    }
    
    .streaming {
      background: rgba(52, 152, 219, 0.3) !important;
      color: #3498db !important;
    }
    
    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.6; }
    }
    
    .streaming {
      animation: pulse 2s ease-in-out infinite;
    }
    
    .visualizer {
      margin: 25px 0;
      height: 60px;
      background: rgba(0, 0, 0, 0.3);
      border-radius: 10px;
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: hidden;
    }
    
    .wave {
      width: 3px;
      background: linear-gradient(to top, #ff6b35, #f7931e);
      margin: 0 1px;
      border-radius: 1px;
      transition: height 0.1s ease;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>üìª FM Radio - HD PCM Player</h1>
    
    <div class="status" id="statusDisplay">
      üéß Ready for live radio
    </div>
    
    <div class="status" id="backgroundStatus" style="display: none; background: rgba(76, 175, 80, 0.3); color: #4CAF50; font-size: 1rem; padding: 15px;">
      üéµ Background Audio Active - Radio continues playing when you switch tabs!
    </div>
    
    <div>
      <button class="btn" id="connectBtn" onclick="startRadio()">
        üéµ Connect to Radio
      </button>
      <button class="btn stop" id="stopBtn" onclick="stopRadio()" style="display: none;">
        ‚èπÔ∏è Stop Radio
      </button>
    </div>
    
    <div class="audio-section" id="audioSection">
      <div class="play-controls">
        <button class="play-btn" id="playBtn" onclick="toggleAudio()">
          ‚ñ∂Ô∏è
        </button>
        
        <div class="volume-control">
          <span>üîä</span>
          <input type="range" id="volumeSlider" class="volume-slider" 
                 min="0" max="100" value="70" onchange="setVolume(this.value)">
          <span id="volumeDisplay">70%</span>
        </div>
      </div>
      
      <div class="visualizer" id="visualizer"></div>
    </div>
    
    <div class="stats">
      <div class="stat">
        <div class="stat-value" id="connectionStat">‚ùå</div>
        <div class="stat-label">Connection</div>
      </div>
      <div class="stat">
        <div class="stat-value" id="chunkStat">0</div>
        <div class="stat-label">Chunks</div>
      </div>
      <div class="stat">
        <div class="stat-value" id="dataStat">0 KB</div>
        <div class="stat-label">Data</div>
      </div>
      <div class="stat">
        <div class="stat-value" id="bufferStat">0%</div>
        <div class="stat-label">Buffer</div>
      </div>
    </div>
  </div>

  <script>
    // Audio variables
    let websocket = null;
    let audioContext = null;
    let gainNode = null;
    let isStreaming = false;
    let isPlaying = false;
    let chunkCount = 0;
    let totalBytes = 0;
    
    // Simple continuous audio approach with optimized settings for smooth playback
    let audioQueue = [];
    let currentSource = null;
    let sampleRate = 48000; // High-quality sample rate
    let scheduleAheadTime = 0.1; // Increased for smoother playback
    let nextNoteTime = 0.0;
    
    // Optimized Audio quality settings for smooth playback
    let audioBufferSize = 4096; // Larger buffer for smoother quality
    let qualityMode = 'smooth'; // Smooth mode flag
    
    // Admin pause/resume detection with stricter thresholds
    window.adminPaused = false;
    window.pauseStartTime = 0;
    window.silenceCount = 0;
    window.audioCount = 0;
    
    // Auto-recovery system for audio breaking
    window.lastAudioTime = 0;
    window.audioBreakDetected = false;
    window.consecutiveGoodChunks = 0;
    
    // Admin stop/start detection (different from pause/resume)
    window.adminStopped = false;
    window.lastChunkTime = 0;
    window.noAudioTimeout = null;
    
    // Enhanced auto-recovery system
    window.autoRecoveryInterval = null;
    window.severeBreakCount = 0;
    window.lastGoodAudioTime = 0;
    
    // Admin page visibility detection
    window.adminPageLeft = false;
    window.lastChunkReceived = 0;
    window.noChunksTimeout = null;
    
    // User page visibility detection for background audio
    window.userPageHidden = false;
    window.backgroundKeepAlive = null;
    window.wakeLock = null;
    window.backgroundAudioActive = false;
    
    // WebSocket connection stability
    window.connectionHeartbeat = null;
    window.reconnectAttempts = 0;
    window.maxReconnectAttempts = 5;
    window.reconnectDelay = 2000;
    
    // DOM elements
    const statusDisplay = document.getElementById('statusDisplay');
    const backgroundStatus = document.getElementById('backgroundStatus');
    const connectBtn = document.getElementById('connectBtn');
    const stopBtn = document.getElementById('stopBtn');
    const audioSection = document.getElementById('audioSection');
    const playBtn = document.getElementById('playBtn');
    const volumeSlider = document.getElementById('volumeSlider');
    const volumeDisplay = document.getElementById('volumeDisplay');
    const visualizer = document.getElementById('visualizer');
    const connectionStat = document.getElementById('connectionStat');
    const chunkStat = document.getElementById('chunkStat');
    const dataStat = document.getElementById('dataStat');
    const bufferStat = document.getElementById('bufferStat');

    // Initialize visualizer
    function createVisualizer() {
      visualizer.innerHTML = '';
      for (let i = 0; i < 40; i++) {
        const wave = document.createElement('div');
        wave.className = 'wave';
        wave.style.height = '5px';
        visualizer.appendChild(wave);
      }
    }

    // Animate visualizer based on audio data
    function animateVisualizer(audioData = null) {
      const waves = visualizer.querySelectorAll('.wave');
      
      if (audioData && isPlaying) {
        // Use actual audio data for visualization
        const step = Math.floor(audioData.length / waves.length);
        waves.forEach((wave, index) => {
          const dataIndex = index * step;
          const amplitude = Math.abs(audioData[dataIndex] || 0);
          const height = Math.min(amplitude * 60 + 5, 50);
          wave.style.height = height + 'px';
        });
      } else {
        // Random animation when not playing
        waves.forEach(wave => {
          const height = Math.random() * (isPlaying ? 30 : 10) + 5;
          wave.style.height = height + 'px';
          wave.style.opacity = isPlaying ? 0.9 : 0.3;
        });
      }
    }

    // Start radio
    async function startRadio() {
      try {
        updateStatus('üîß Initializing Web Audio API...', 'streaming');
        
        // Create Web Audio context with HD settings
        audioContext = new (window.AudioContext || window.webkitAudioContext)({
          sampleRate: sampleRate,
          latencyHint: 'interactive' // Optimized for real-time audio
        });
        
        await audioContext.resume();
        
        // Create gain node for volume control with balanced processing
        gainNode = audioContext.createGain();
        
        // Add gentle noise reduction without aggressive gating (which causes artifacts)
        const gentleCompressor = audioContext.createDynamicsCompressor();
        gentleCompressor.threshold.setValueAtTime(-30, audioContext.currentTime); // Moderate threshold
        gentleCompressor.knee.setValueAtTime(12, audioContext.currentTime); // Soft knee for natural sound
        gentleCompressor.ratio.setValueAtTime(3, audioContext.currentTime); // Gentle compression
        gentleCompressor.attack.setValueAtTime(0.01, audioContext.currentTime); // Natural attack
        gentleCompressor.release.setValueAtTime(0.2, audioContext.currentTime); // Natural release
        
        // Connect clean audio chain: gainNode -> gentle compressor -> destination
        gainNode.connect(gentleCompressor);
        gentleCompressor.connect(audioContext.destination);
        gainNode.gain.value = 0.8; // Balanced gain level
        
        updateStatus('üåê Connecting to radio server...', 'streaming');
        
        // Connect to WebSocket
        await connectWebSocket();
        
        // Initialize streaming
        isStreaming = true;
        chunkCount = 0;
        totalBytes = 0;
        audioQueue = [];
        nextNoteTime = 0;
        
        // Start continuous auto-recovery monitoring
        startAutoRecoveryMonitor();
        
        // Update UI
        connectBtn.style.display = 'none';
        stopBtn.style.display = 'inline-block';
        audioSection.style.display = 'block';
        
        createVisualizer();
        setInterval(() => animateVisualizer(), 100);
        
        updateStatus('‚úÖ Connected! Receiving HD audio...', 'success');
        
        console.log('üéß PCM radio streaming started');
        
      } catch (error) {
        console.error('‚ùå Failed to start radio:', error);
        updateStatus('‚ùå Failed to start: ' + error.message, 'error');
      }
    }

    // Connect to WebSocket
    function connectWebSocket() {
      return new Promise((resolve, reject) => {
        try {
          const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
          const wsUrl = protocol + '//' + window.location.host;
          
          console.log('üîó Connecting to:', wsUrl);
          
          websocket = new WebSocket(wsUrl);
          websocket.binaryType = 'arraybuffer';
          
          websocket.onopen = () => {
            console.log('‚úÖ WebSocket connected');
            connectionStat.textContent = '‚úÖ';
            window.reconnectAttempts = 0; // Reset reconnect attempts on successful connection
            startConnectionHeartbeat(); // Start heartbeat to maintain connection
            resolve();
          };
          
          websocket.onmessage = async (event) => {
            if (isStreaming) {
              // Handle heartbeat pong responses
              if (typeof event.data === 'string' && event.data === 'pong') {
                console.log('üíó Received heartbeat pong');
                return;
              }
              
              // Handle binary PCM data
              if (event.data instanceof ArrayBuffer) {
                await handlePCMData(event.data);
              }
            }
          };
          
          websocket.onclose = (event) => {
            console.log('‚ùå WebSocket disconnected:', event.code, event.reason);
            stopConnectionHeartbeat();
            
            // Only attempt reconnection if we were streaming and it wasn't a manual disconnect
            if (isStreaming && event.code !== 1000 && window.reconnectAttempts < window.maxReconnectAttempts) {
              console.log(`üîÑ Attempting reconnection ${window.reconnectAttempts + 1}/${window.maxReconnectAttempts}`);
              updateStatus(`üîÑ Reconnecting... (${window.reconnectAttempts + 1}/${window.maxReconnectAttempts})`, 'streaming');
              
              setTimeout(() => {
                window.reconnectAttempts++;
                reconnectWebSocket();
              }, window.reconnectDelay);
              
              // Increase delay for next attempt (exponential backoff)
              window.reconnectDelay = Math.min(window.reconnectDelay * 1.5, 10000);
            } else {
              updateStatus('‚ùå Connection lost', 'error');
              connectionStat.textContent = '‚ùå';
            }
          };
          
          websocket.onerror = (error) => {
            console.error('‚ùå WebSocket error:', error);
            updateStatus('‚ùå Connection failed', 'error');
            connectionStat.textContent = '‚ùå';
            reject(new Error('WebSocket connection failed'));
          };
          
        } catch (error) {
          console.error('‚ùå Failed to create WebSocket:', error);
          reject(error);
        }
      });
    }

    // Start connection heartbeat to prevent disconnections
    function startConnectionHeartbeat() {
      stopConnectionHeartbeat(); // Clear any existing heartbeat
      
      window.connectionHeartbeat = setInterval(() => {
        if (websocket && websocket.readyState === WebSocket.OPEN) {
          // Send a ping to keep connection alive
          try {
            websocket.send('ping');
          } catch (error) {
            console.log('‚ö†Ô∏è Heartbeat failed:', error);
            stopConnectionHeartbeat();
          }
        } else {
          stopConnectionHeartbeat();
        }
      }, 30000); // Send heartbeat every 30 seconds
    }
    
    // Stop connection heartbeat
    function stopConnectionHeartbeat() {
      if (window.connectionHeartbeat) {
        clearInterval(window.connectionHeartbeat);
        window.connectionHeartbeat = null;
      }
    }
    
    // Reconnect WebSocket
    async function reconnectWebSocket() {
      try {
        if (websocket) {
          websocket.close();
        }
        await connectWebSocket();
        console.log('‚úÖ WebSocket reconnected successfully');
        updateStatus('‚úÖ Reconnected to server!', 'success');
      } catch (error) {
        console.error('‚ùå Reconnection failed:', error);
        // The onclose handler will trigger another reconnect attempt if needed
      }
    }

    // Handle incoming PCM data with automatic break detection
    async function handlePCMData(arrayBuffer) {
      chunkCount++;
      totalBytes += arrayBuffer.byteLength;
      
      // Update stats
      chunkStat.textContent = chunkCount;
      dataStat.textContent = formatBytes(totalBytes);
      bufferStat.textContent = Math.min(audioQueue.length * 5, 100) + '%';
      
      const currentTime = Date.now();
      
      // Clear any pending "no audio" timeout since we just received audio
      if (window.noAudioTimeout) {
        clearTimeout(window.noAudioTimeout);
        window.noAudioTimeout = null;
      }
      
      // Clear any "no chunks" timeout since we just received a chunk
      if (window.noChunksTimeout) {
        clearTimeout(window.noChunksTimeout);
        window.noChunksTimeout = null;
      }
      
      // Track when we last received a chunk for admin page detection
      window.lastChunkReceived = currentTime;
      
      // Set timeout to detect if admin left the page (no chunks for 3+ seconds)
      window.noChunksTimeout = setTimeout(() => {
        if (!window.adminPageLeft && isStreaming) {
          window.adminPageLeft = true;
          console.log('üì± Admin appears to have LEFT the page (3+ sec no chunks)');
          updateStatus('üì± Admin left page - audio paused...', 'streaming');
          
          // Don't clear audio immediately - wait for admin to return
          // Just mark the state for better handling
        }
      }, 3000);
      
      // Admin stop/start detection - if no audio for 2+ seconds, consider admin stopped
      window.lastChunkTime = currentTime;
      window.noAudioTimeout = setTimeout(() => {
        if (!window.adminStopped && isStreaming) {
          window.adminStopped = true;
          console.log('üõë Admin appears to have STOPPED streaming (2+ sec silence)');
          updateStatus('üõë Admin stopped - waiting for restart...', 'error');
          
          // Clear stale audio when admin stops
          audioQueue = [];
          if (audioContext && isPlaying) {
            nextNoteTime = audioContext.currentTime + 0.1;
          }
        }
      }, 2000);
      
      // Detect admin return to page after leaving (fresh chunks after long absence)
      if (window.adminPageLeft) {
        window.adminPageLeft = false;
        console.log('üì± Admin RETURNED to page - doing PAGE RETURN RESET');
        
        // Page return reset - similar to restart but gentler
        audioQueue = audioQueue.slice(-2); // Keep only 2 most recent chunks
        
        // Reset timing and detection systems
        window.lastAudioTime = currentTime;
        window.lastGoodAudioTime = currentTime;
        window.audioBreakDetected = false;
        window.consecutiveGoodChunks = 0;
        window.adminPaused = false;
        window.pauseStartTime = 0;
        window.silenceCount = 0;
        window.audioCount = 0;
        window.severeBreakCount = 0; // Reset severe break counter
        
        if (audioContext && isPlaying) {
          nextNoteTime = audioContext.currentTime + 0.03; // Quick sync
        }
        
        updateStatus('üì± Admin returned - syncing audio...', 'success');
        console.log('üì± PAGE RETURN RESET: Audio synced for admin return');
      }
      
      // Detect admin restart after stop (fresh audio after long silence)
      if (window.adminStopped) {
        window.adminStopped = false;
        console.log('üîÑ Admin RESTARTED streaming - doing COMPLETE RESET');
        
        // COMPLETE RESET for admin restart (much more aggressive than pause/resume)
        audioQueue = []; // Clear ALL old audio
        chunkCount = 1; // Reset chunk counter for fresh start
        totalBytes = arrayBuffer.byteLength; // Reset data counter
        
        // Reset ALL timing and detection systems
        window.lastAudioTime = currentTime;
        window.audioBreakDetected = false;
        window.consecutiveGoodChunks = 0;
        window.adminPaused = false;
        window.pauseStartTime = 0;
        window.silenceCount = 0;
        window.audioCount = 0;
        
        if (audioContext && isPlaying) {
          nextNoteTime = audioContext.currentTime + 0.05; // Fresh timing start
        }
        
        updateStatus('üî¥ LIVE - Admin restarted with fresh sync!', 'success');
        console.log('üí• COMPLETE RESET: All systems cleared for admin restart');
      }
      
      // Detect audio breaks - if chunks are coming too slowly or irregularly
      if (window.lastAudioTime > 0) {
        const timeDiff = currentTime - window.lastAudioTime;
        
        // If chunk arrives more than 200ms late, it might cause breaking
        if (timeDiff > 200) {
          window.audioBreakDetected = true;
          window.consecutiveGoodChunks = 0;
          
          console.log(`‚ö†Ô∏è Audio break detected! Chunk delayed by ${timeDiff}ms - auto-recovery in 1 sec`);
          
          // Immediate recovery - clear buffers and reset timing
          audioQueue = audioQueue.slice(-2); // Keep only 2 most recent chunks
          
          if (audioContext && isPlaying) {
            nextNoteTime = audioContext.currentTime + 0.05; // Quick restart
          }
          
          updateStatus('ÔøΩ Auto-recovering from audio break...', 'streaming');
          
          // Mark recovery complete after 1 second
          setTimeout(() => {
            if (window.consecutiveGoodChunks >= 3) {
              window.audioBreakDetected = false;
              updateStatus('‚úÖ Audio recovered - streaming smoothly!', 'success');
              console.log('‚úÖ Auto-recovery complete - audio stable');
            }
          }, 1000);
        } else if (timeDiff < 150) {
          // Good timing - increment recovery counter
          window.consecutiveGoodChunks++;
          if (window.audioBreakDetected && window.consecutiveGoodChunks >= 5) {
            window.audioBreakDetected = false;
            updateStatus('üî¥ LIVE - Audio recovered!', 'success');
            console.log('üéµ Audio break resolved - back to normal streaming');
          }
        }
      }
      
      window.lastAudioTime = currentTime;
      window.lastGoodAudioTime = currentTime; // Track last truly good audio
      
      console.log(`üì° PCM chunk ${chunkCount}: ${arrayBuffer.byteLength} bytes, queue: ${audioQueue.length}, delay: ${window.lastAudioTime ? currentTime - window.lastAudioTime : 0}ms`);
      
      // Convert ArrayBuffer to Float32Array for HD audio processing
      const pcmData = new Int16Array(arrayBuffer);
      const floatData = new Float32Array(pcmData.length);
      
      // Clean int16 to float32 conversion with minimal processing
      let maxAmplitude = 0;
      for (let i = 0; i < pcmData.length; i++) {
        // Simple, clean conversion without over-processing
        let sample = pcmData[i] / 32768.0;
        
        // Only eliminate truly silent samples (much more conservative)
        if (Math.abs(sample) < 0.000001) sample = 0;
        
        // Gentle limiting only for extreme values
        if (sample > 0.995) sample = 0.995;
        if (sample < -0.995) sample = -0.995;
        
        floatData[i] = sample;
        maxAmplitude = Math.max(maxAmplitude, Math.abs(sample));
      }
      
      // Balanced admin pause/resume detection
      if (maxAmplitude < 0.001) { // Reasonable threshold for silence detection
        window.silenceCount++;
        window.audioCount = 0; // Reset audio counter
        
        // Only trigger pause detection after longer consistent silence (10+ chunks for stability)
        if (window.silenceCount > 10 && !window.adminPaused) {
          window.adminPaused = true;
          window.pauseStartTime = Date.now();
          console.log('üîá Admin paused - detected after ' + window.silenceCount + ' silent chunks');
          
          // Gentler clear - don't clear ALL audio immediately
          if (audioQueue.length > 8) {
            audioQueue = audioQueue.slice(-4); // Keep some recent audio
          }
          if (audioContext && isPlaying) {
            nextNoteTime = audioContext.currentTime + 0.1;
          }
          
          updateStatus('‚è∏Ô∏è Admin paused - standby mode', 'streaming');
        }
      } else {
        window.audioCount++;
        window.silenceCount = 0; // Reset silence counter
        
        // Audio detected - check for resume (need more audio chunks for stability)
        if (window.adminPaused && window.audioCount > 3) { // Need 3+ audio chunks to confirm resume
          window.adminPaused = false;
          const pauseDuration = Date.now() - window.pauseStartTime;
          
          console.log('üîÑ Admin resumed after ' + pauseDuration + 'ms - gentle sync');
          
          // Gentler resume - only clear if pause was very long
          if (pauseDuration > 3000) {
            audioQueue = audioQueue.slice(-6); // Keep more recent audio
          }
          
          if (audioContext && isPlaying) {
            nextNoteTime = audioContext.currentTime + 0.05; // Quick but gentle restart
          }
          
          // Reset counters
          window.pauseStartTime = 0;
          window.silenceCount = 0;
          window.audioCount = 0;
          window.lastAudioTime = Date.now();
          
          updateStatus('üî¥ LIVE - Admin resumed!', 'success');
          console.log('‚úÖ Gentle resume complete');
        }
      }
      
      // Add to audio queue (with aggressive filtering during admin pause/resume)
      if (window.adminPaused) {
        // During admin pause, don't add any audio to prevent stale data
        console.log('‚è∏Ô∏è Admin paused - rejecting audio chunk');
      } else if (window.audioBreakDetected) {
        // During recovery, keep queue very small
        if (audioQueue.length < 2) {
          audioQueue.push(floatData);
        }
      } else {
        // Normal operation - but always check if we need immediate clear
        audioQueue.push(floatData);
      }
      
      // Animate visualizer with actual audio data
      if (isPlaying) {
        animateVisualizer(floatData);
      }
      
      // Auto-enable play after receiving some data
      if (chunkCount === 2 && !isPlaying) {
        updateStatus('üéµ Ready! Click ‚ñ∂Ô∏è to hear audio', 'success');
      }
      
      // Keep queue optimized for ultra-smooth playbook with larger buffer
      if (audioQueue.length > 25) {
        console.log('üóëÔ∏è Queue optimization - maintaining large smooth buffer');
        audioQueue = audioQueue.slice(-20); // Keep even more chunks for ultra-smooth audio
      }
    }

    // Reset audio timing for smooth restart after admin pause
    function resetAudioTiming() {
      if (!audioContext || !isPlaying) return;
      
      try {
        console.log('üîß Resetting audio timing...');
        
        // Clear existing queue to prevent stale audio
        audioQueue = [];
        
        // Reset timing to current time + small delay
        nextNoteTime = audioContext.currentTime + 0.1;
        
        console.log('‚úÖ Audio timing reset complete');
        
      } catch (error) {
        console.error('‚ùå Timing reset error:', error);
      }
    }

    // Enhanced scheduling with better continuity and less breaking
    function scheduleAudio() {
      if (!audioContext || !isPlaying) return;
      
      const currentTime = audioContext.currentTime;
      
      // More gentle break detection - less aggressive resetting
      if (nextNoteTime < currentTime - 0.5) {
        console.log('ÔøΩ Audio timing reset - gap was too large');
        nextNoteTime = currentTime + 0.02; // Smaller gap
      } else if (nextNoteTime < currentTime) {
        // Minor lag - just adjust slightly
        nextNoteTime = currentTime + 0.01;
      }
      
      // Schedule multiple chunks ahead for smoother playback
      let scheduled = 0;
      const maxSchedule = 6; // Always keep 6 chunks scheduled for smoothness
      
      while (nextNoteTime < currentTime + scheduleAheadTime && audioQueue.length > 0 && scheduled < maxSchedule) {
        playAudioAtTime(nextNoteTime);
        scheduled++;
      }
      
      // Update good audio time when we successfully schedule
      if (scheduled > 0) {
        window.lastGoodAudioTime = Date.now();
      }
      
      // Continue scheduling with consistent timing
      if (isPlaying) {
        // Use setTimeout for more consistent scheduling
        setTimeout(scheduleAudio, 25); // More reasonable 25ms intervals for smooth but not aggressive scheduling
      }
    }

    // Play single audio chunk at specific time with HD quality
    function playAudioAtTime(time) {
      if (audioQueue.length === 0) return;
      
      const audioData = audioQueue.shift();
      
      try {
        // Create high-quality audio buffer
        const audioBuffer = audioContext.createBuffer(1, audioData.length, sampleRate);
        const channelData = audioBuffer.getChannelData(0);
        
        // Apply gentle windowing to prevent clicks without introducing artifacts
        const windowSize = Math.min(32, audioData.length / 8); // Much smaller window for minimal processing
        const windowedData = new Float32Array(audioData.length);
        
        for (let i = 0; i < audioData.length; i++) {
          let sample = audioData[i];
          
          // Apply very gentle cosine windowing only at the very edges
          if (i < windowSize) {
            // Gentle cosine fade-in
            const fadeVal = 0.5 * (1 - Math.cos(Math.PI * i / windowSize));
            sample *= fadeVal;
          } else if (i >= audioData.length - windowSize) {
            // Gentle cosine fade-out
            const fadeVal = 0.5 * (1 - Math.cos(Math.PI * (audioData.length - i) / windowSize));
            sample *= fadeVal;
          }
          
          windowedData[i] = sample;
        }
        
        channelData.set(windowedData);
        
        // Create and configure HD source
        const source = audioContext.createBufferSource();
        source.buffer = audioBuffer;
        
        // Add subtle interpolation for smoother playback
        source.connect(gainNode);
        
        // Schedule playbook with ultra-precise timing and noise-free transitions
        if (time < audioContext.currentTime) {
          time = audioContext.currentTime + 0.003; // Ultra-minimal delay for perfect timing
        }
        
        source.start(time);
        
        // Update next time with minimal overlap to prevent gaps without causing artifacts
        const bufferDuration = audioBuffer.duration;
        nextNoteTime = time + bufferDuration - 0.0005; // Minimal overlap to prevent gaps
        
        console.log(`üéµ HD Audio scheduled at ${time.toFixed(4)}s, next: ${nextNoteTime.toFixed(4)}s, queue: ${audioQueue.length}`);
        
      } catch (error) {
        console.error('‚ùå HD Audio play error:', error);
      }
    }

    // Continuous auto-recovery monitoring system (less aggressive to prevent breaking)
    function startAutoRecoveryMonitor() {
      // Clear any existing monitor
      if (window.autoRecoveryInterval) {
        clearInterval(window.autoRecoveryInterval);
      }
      
      window.autoRecoveryInterval = setInterval(() => {
        if (!isStreaming || !isPlaying || window.backgroundAudioActive) return; // Don't interfere with background mode
        
        const currentTime = Date.now();
        const timeSinceLastAudio = currentTime - window.lastGoodAudioTime;
        const timeSinceLastChunk = currentTime - window.lastChunkTime;
        const timeSinceChunkReceived = currentTime - window.lastChunkReceived;
        
        // Less aggressive detection to prevent unnecessary breaking
        if (timeSinceLastAudio > 2000 && audioQueue.length < 1 && !window.adminPageLeft) {
          console.log('üîß AUTO-RECOVERY: Audio completely starved - gentle reset');
          forceAudioReset('Audio starvation detected');
          
        } else if (timeSinceLastChunk > 3000 && !window.adminPageLeft) {
          console.log('üîß AUTO-RECOVERY: No chunks for 3+ sec - gentle reset');
          forceAudioReset('Chunk starvation detected');
          
        } else if (timeSinceChunkReceived > 5000 && !window.adminPageLeft) {
          // Admin might have left page but timeout didn't trigger yet
          console.log('üîß AUTO-RECOVERY: Admin likely left page - gentle reset');
          window.adminPageLeft = true;
          updateStatus('üì± Admin left page - waiting for return...', 'streaming');
          
        } else if (audioQueue.length > 20) {
          console.log('üîß AUTO-RECOVERY: Queue overflow - gentle optimization');
          audioQueue = audioQueue.slice(-12); // Keep more chunks for smoother audio
          if (audioContext && isPlaying) {
            nextNoteTime = audioContext.currentTime + 0.05; // Gentler restart
          }
          
        } else if (nextNoteTime < audioContext.currentTime - 1.0 && !window.adminPageLeft) {
          console.log('üîß AUTO-RECOVERY: Major timing drift - gentle reset');
          forceAudioReset('Major timing drift');
          window.severeBreakCount++;
          
          // Only simulate restart after many severe breaks
          if (window.severeBreakCount >= 5) {
            console.log('üö® MULTIPLE SEVERE BREAKS - Simulating admin restart');
            simulateAdminRestart();
            window.severeBreakCount = 0;
          }
        }
        
      }, 1000); // Check every 1000ms for much gentler recovery
    }
    
    // Force immediate audio reset (like admin restart but without waiting)
    function forceAudioReset(reason) {
      console.log(`üí• FORCE RESET: ${reason}`);
      
      // Complete audio system reset
      audioQueue = [];
      window.audioBreakDetected = false;
      window.consecutiveGoodChunks = 0;
      window.adminPaused = false;
      window.silenceCount = 0;
      window.audioCount = 0;
      
      if (audioContext && isPlaying) {
        nextNoteTime = audioContext.currentTime + 0.02; // Very quick restart
      }
      
      updateStatus('üîß Auto-recovery: ' + reason, 'streaming');
      
      // Reset tracking
      window.lastGoodAudioTime = Date.now();
      window.lastAudioTime = Date.now();
    }
    
    // Simulate admin restart for severe cases
    function simulateAdminRestart() {
      console.log('üîÑ SIMULATING ADMIN RESTART for recovery');
      
      // Reset all counters as if admin restarted
      chunkCount = 0;
      totalBytes = 0;
      audioQueue = [];
      
      // Reset all detection systems
      window.adminPaused = false;
      window.adminStopped = false;
      window.pauseStartTime = 0;
      window.silenceCount = 0;
      window.audioCount = 0;
      window.lastAudioTime = Date.now();
      window.lastGoodAudioTime = Date.now();
      window.lastChunkTime = Date.now();
      window.audioBreakDetected = false;
      window.consecutiveGoodChunks = 0;
      
      if (audioContext && isPlaying) {
        nextNoteTime = audioContext.currentTime + 0.05;
      }
      
      updateStatus('üîÑ Simulated restart - fresh sync!', 'success');
      console.log('üí• SIMULATED RESTART COMPLETE');
    }

    // Toggle audio playback
    async function toggleAudio() {
      if (!isStreaming) {
        updateStatus('‚ùå Please connect to radio first', 'error');
        return;
      }
      
      try {
        if (isPlaying) {
          // Stop playing
          isPlaying = false;
          playBtn.textContent = '‚ñ∂Ô∏è';
          
          // Stop background audio mode if active
          if (window.backgroundAudioActive) {
            stopBackgroundAudioMode();
          }
          
          updateStatus('‚è∏Ô∏è Audio paused', 'success');
          
        } else {
          // Start playing with minimal disruption
          if (audioContext.state === 'suspended') {
            await audioContext.resume();
          }
          
          isPlaying = true;
          
          // Much gentler reset - maintain larger buffer for smoothness
          if (audioQueue.length > 15) {
            audioQueue = audioQueue.slice(-10); // Keep more recent audio for smoothness
          }
          
          nextNoteTime = audioContext.currentTime + 0.1; // Slightly longer startup buffer
          
          // Reset all detection systems including auto-recovery
          window.adminPaused = false;
          window.adminStopped = false;
          window.adminPageLeft = false;
          window.pauseStartTime = 0;
          window.silenceCount = 0;
          window.audioCount = 0;
          window.lastAudioTime = Date.now();
          window.lastChunkTime = Date.now();
          window.lastGoodAudioTime = Date.now();
          window.lastChunkReceived = Date.now();
          window.audioBreakDetected = false;
          window.consecutiveGoodChunks = 0;
          window.severeBreakCount = 0;
          
          // Clear any pending timeouts
          if (window.noAudioTimeout) {
            clearTimeout(window.noAudioTimeout);
            window.noAudioTimeout = null;
          }
          
          if (window.noChunksTimeout) {
            clearTimeout(window.noChunksTimeout);
            window.noChunksTimeout = null;
          }
          
          // Start monitoring system
          startAutoRecoveryMonitor();
          
          playBtn.textContent = '‚è∏Ô∏è';
          
          // If user is on a different tab, immediately start background mode
          if (document.hidden) {
            startBackgroundAudioMode();
          } else {
            updateStatus('üéµ Playing HD audio with auto-recovery!', 'success');
          }
          
          console.log('üéß HD Audio playback started with break detection enabled');
          
          // Start the audio scheduling loop
          scheduleAudio();
        }
        
      } catch (error) {
        console.error('‚ùå Audio toggle error:', error);
        updateStatus('‚ùå Audio error: ' + error.message, 'error');
      }
    }

    // Set volume
    function setVolume(value) {
      const volume = value / 100;
      if (gainNode) {
        gainNode.gain.value = volume;
      }
      volumeDisplay.textContent = value + '%';
    }

    // Stop radio
    function stopRadio() {
      isStreaming = false;
      isPlaying = false;
      isProcessingAudio = false;
      
      // Clear buffer
      audioQueue = [];
      
      // Close Web Audio Context
      if (audioContext) {
        audioContext.close();
        audioContext = null;
      }
      
      // Close WebSocket and stop heartbeat
      if (websocket) {
        websocket.close();
      }
      stopConnectionHeartbeat();
      
      // Stop background audio mode if active
      if (window.backgroundAudioActive) {
        stopBackgroundAudioMode();
      }
      
      // Reset variables
      gainNode = null;
      chunkCount = 0;
      totalBytes = 0;
      
      // Reset connection variables
      window.reconnectAttempts = 0;
      window.reconnectDelay = 2000;
      
      // Reset all detection systems
      window.adminPaused = false;
      window.adminStopped = false;
      window.adminPageLeft = false;
      window.pauseStartTime = 0;
      window.silenceCount = 0;
      window.audioCount = 0;
      window.lastAudioTime = 0;
      window.lastChunkTime = 0;
      window.lastChunkReceived = 0;
      window.audioBreakDetected = false;
      window.consecutiveGoodChunks = 0;
      window.severeBreakCount = 0;
      window.lastGoodAudioTime = 0;
      
      // Clear any pending timeouts and intervals
      if (window.noAudioTimeout) {
        clearTimeout(window.noAudioTimeout);
        window.noAudioTimeout = null;
      }
      
      if (window.noChunksTimeout) {
        clearTimeout(window.noChunksTimeout);
        window.noChunksTimeout = null;
      }
      
      if (window.autoRecoveryInterval) {
        clearInterval(window.autoRecoveryInterval);
        window.autoRecoveryInterval = null;
      }
      
      // Update UI
      connectBtn.style.display = 'inline-block';
      stopBtn.style.display = 'none';
      audioSection.style.display = 'none';
      playBtn.textContent = '‚ñ∂Ô∏è';
      
      updateStatus('‚èπÔ∏è Radio stopped');
      connectionStat.textContent = '‚ùå';
      
      console.log('‚èπÔ∏è PCM radio streaming stopped');
    }

    // Update status display
    function updateStatus(message, type = '') {
      statusDisplay.textContent = message;
      statusDisplay.className = 'status';
      if (type) {
        statusDisplay.classList.add(type);
      }
    }

    // Format bytes for display
    function formatBytes(bytes) {
      if (bytes === 0) return '0 B';
      const k = 1024;
      const sizes = ['B', 'KB', 'MB'];
      const i = Math.floor(Math.log(bytes) / Math.log(k));
      return Math.round(bytes / Math.pow(k, i)) + ' ' + sizes[i];
    }

    // Cleanup on page unload
    window.addEventListener('beforeunload', () => {
      if (websocket) websocket.close();
      if (audioContext) audioContext.close();
      if (window.wakeLock) window.wakeLock.release();
      if (window.backgroundKeepAlive) clearInterval(window.backgroundKeepAlive);
      stopConnectionHeartbeat();
    });
    
    // Handle page visibility changes with ultra-aggressive background audio
    document.addEventListener('visibilitychange', function() {
      if (document.hidden) {
        // User switched to another tab/window - IMMEDIATELY go into protection mode
        window.userPageHidden = true;
        console.log('üì± User switched AWAY - IMMEDIATE background protection');
        
        if (isPlaying && isStreaming) {
          // Don't wait - immediately start aggressive mode
          startBackgroundAudioMode();
          
          // Also force audio context to stay active
          if (audioContext && audioContext.state !== 'running') {
            audioContext.resume().catch(e => console.log('Immediate resume failed:', e));
          }
        }
        
      } else {
        // User returned to the radio tab
        window.userPageHidden = false;
        console.log('üì± User RETURNED - optimizing for foreground');
        
        if (window.backgroundAudioActive) {
          stopBackgroundAudioMode();
          resumeForegroundAudio();
        }
      }
    });
    
    // IMMEDIATELY handle focus/blur events for better compatibility
    window.addEventListener('blur', function() {
      if (isPlaying && isStreaming && !window.backgroundAudioActive) {
        console.log('üîÑ Window lost focus - INSTANT background protection');
        startBackgroundAudioMode();
        
        // Force audio context resume
        if (audioContext && audioContext.state !== 'running') {
          audioContext.resume().catch(e => console.log('Blur resume failed:', e));
        }
      }
    });
    
    window.addEventListener('focus', function() {
      if (window.backgroundAudioActive) {
        console.log('üîÑ Window gained focus - returning to foreground');
        stopBackgroundAudioMode();
        resumeForegroundAudio();
      }
    });
    
    // Add page freeze/unfreeze handling for mobile
    document.addEventListener('freeze', function() {
      console.log('üì± Page frozen - maintaining audio');
      if (isPlaying && isStreaming) {
        startBackgroundAudioMode();
      }
    });
    
    document.addEventListener('resume', function() {
      console.log('üì± Page resumed from freeze');
      if (window.backgroundAudioActive) {
        stopBackgroundAudioMode();
        resumeForegroundAudio();
      }
    });
    
    // Start ultra-aggressive background audio mode to prevent tab switching breaks
    async function startBackgroundAudioMode() {
      console.log('üîÑ Starting ULTRA-AGGRESSIVE background audio mode...');
      window.backgroundAudioActive = true;
      
      // Request wake lock to prevent audio interruption
      try {
        if ('wakeLock' in navigator) {
          window.wakeLock = await navigator.wakeLock.request('screen');
          console.log('üîí Wake lock acquired for background audio');
        }
      } catch (error) {
        console.log('‚ö†Ô∏è Wake lock not available:', error.message);
      }
      
      // ULTRA aggressive keep-alive interval to prevent ANY audio breaking
      window.backgroundKeepAlive = setInterval(() => {
        if (isPlaying && audioContext) {
          // Always ensure audio context is running - but more gently
          if (audioContext.state !== 'running') {
            console.log('üîÑ Force resuming audio context in background');
            audioContext.resume().catch(e => console.log('Resume failed:', e));
          }
          
          // Force continuous audio scheduling in background with zero tolerance
          if (audioQueue.length > 0) {
            const currentTime = audioContext.currentTime;
            
            // Don't let timing drift AT ALL in background
            if (nextNoteTime < currentTime + 0.05) {
              nextNoteTime = currentTime + 0.05;
              console.log('üîÑ Background audio timing force correction');
            }
            
            // Force aggressive scheduling to prevent gaps
            let scheduled = 0;
            while (nextNoteTime < currentTime + 0.2 && audioQueue.length > 0 && scheduled < 8) {
              playAudioAtTime(nextNoteTime);
              scheduled++;
            }
            
            if (scheduled > 0) {
              console.log(`üéµ Background force scheduled ${scheduled} chunks`);
            }
          }
          
          // Don't create dummy audio - it can cause noise
          // Instead, just ensure scheduling continues aggressively
        }
        
        // Force audio data processing even in background
        if (audioQueue.length < 5 && isStreaming) {
          console.log('‚ö†Ô∏è Background audio queue low - requesting more data');
        }
        
      }, 200); // Much gentler background checks - every 200ms instead of 50ms
      
      updateStatus('üéß ULTRA Background Mode - Zero breaking tolerance!', 'success');
      backgroundStatus.style.display = 'block';
    }
    
    // Stop background audio mode
    function stopBackgroundAudioMode() {
      console.log('‚èπÔ∏è Stopping background audio mode...');
      window.backgroundAudioActive = false;
      
      // Release wake lock
      if (window.wakeLock) {
        window.wakeLock.release();
        window.wakeLock = null;
        console.log('üîì Wake lock released');
      }
      
      // Stop keep-alive interval
      if (window.backgroundKeepAlive) {
        clearInterval(window.backgroundKeepAlive);
        window.backgroundKeepAlive = null;
      }
      
      backgroundStatus.style.display = 'none';
    }
    
    // Resume foreground audio with optimization
    async function resumeForegroundAudio() {
      console.log('üîÑ Resuming foreground audio...');
      
      // Ensure audio context is running
      if (audioContext && audioContext.state !== 'running') {
        try {
          await audioContext.resume();
          console.log('‚úÖ Audio context resumed for foreground');
        } catch (error) {
          console.error('‚ùå Failed to resume audio context:', error);
        }
      }
      
      // Optimize audio queue for smooth resumption
      if (audioQueue.length > 8) {
        console.log('üóëÔ∏è Optimizing audio queue for foreground return');
        audioQueue = audioQueue.slice(-4); // Keep only recent audio for smooth resumption
      }
      
      // Reset timing for immediate audio
      if (isPlaying && audioContext) {
        nextNoteTime = audioContext.currentTime + 0.02;
        console.log('‚è∞ Audio timing reset for foreground return');
      }
      
      updateStatus('üî¥ LIVE - Resumed foreground audio!', 'success');
    }

    // Initialize and add user interaction handlers
    window.addEventListener('load', () => {
      console.log('üìª HD PCM FM Radio Player loaded');
      
      // Add user interaction handlers to ensure audio can play
      const enableAudioContext = async () => {
        if (audioContext && audioContext.state === 'suspended') {
          try {
            await audioContext.resume();
            console.log('‚úÖ Audio context resumed after user interaction');
          } catch (error) {
            console.log('‚ö†Ô∏è Failed to resume audio context:', error);
          }
        }
      };
      
      // Listen for user interactions to enable audio
      document.addEventListener('click', enableAudioContext, { once: true });
      document.addEventListener('touchstart', enableAudioContext, { once: true });
      document.addEventListener('keydown', enableAudioContext, { once: true });
      
      // Prevent audio context suspension on mobile
      document.addEventListener('touchend', () => {
        if (isPlaying && audioContext && audioContext.state === 'suspended') {
          audioContext.resume().catch(e => console.log('Resume after touch failed:', e));
        }
      });
    });
  </script>
</body>
</html>
