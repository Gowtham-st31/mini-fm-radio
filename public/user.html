
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>FM Radio - PCM Player</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      text-align: center;
      padding: 20px;
      margin: 0;
      min-height: 100vh;
    }
    
    .container {
      max-width: 600px;
      margin: 0 auto;
      ba                    // Check if we're resuming from pause
          if (streamState === 'paused' && consecutiveAudioChunks >= 2) {
            console.log('üîÑ Stream resumed - restarting audio system');
            streamState = 'restarting';
            
            // Complete system reset for clean restart
            resetAudioSystem();
            
            streamState = 'active';
            updateStatus('üî¥ LIVE - Stream resumed successfully!', 'success');
          } we're resuming from pause
          if (streamState === 'paused' && consecutiveAudioChunks >= 2) {
            console.log('üîÑ Stream resumed - restarting audio system');
            streamState = 'restarting';
            
            // Complete system reset for clean restart
            resetAudioSystem();
            
            streamState = 'active';
            updateStatus('üî¥ LIVE - Stream resumed successfully!', 'success');
          }gba(255, 255, 255, 0.1);
      padding: 40px;
      border-radius: 20px;
      backdrop-filter: blur(10px);
    }
    
    h1 {
      color: #ff6b35;
      margin-bottom: 30px;
      font-size: 2.5rem;
    }
    
    .status {
      padding: 20px;
      margin: 20px 0;
      background: rgba(0, 0, 0, 0.3);
      border-radius: 15px;
      font-size: 1.2rem;
      min-height: 60px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    .btn {
      background: linear-gradient(45deg, #ff6b35, #f7931e);
      color: white;
      border: none;
      padding: 18px 35px;
      font-size: 1.2rem;
      border-radius: 30px;
      cursor: pointer;
      margin: 15px;
      min-width: 200px;
      font-weight: 600;
    }
    
    .btn:disabled {
      background: #666;
      cursor: not-allowed;
    }
    
    .btn.stop {
      background: linear-gradient(45deg, #e74c3c, #c0392b);
    }
    
    .audio-section {
      margin: 30px 0;
      padding: 25px;
      background: rgba(0, 0, 0, 0.2);
      border-radius: 15px;
      display: none;
    }
    
    .play-controls {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 25px;
      margin: 25px 0;
    }
    
    .play-btn {
      background: linear-gradient(45deg, #27ae60, #2ecc71);
      color: white;
      border: none;
      width: 80px;
      height: 80px;
      border-radius: 50%;
      font-size: 2rem;
      cursor: pointer;
    }
    
    .volume-control {
      display: flex;
      align-items: center;
      gap: 10px;
    }
    
    .volume-slider {
      width: 120px;
      height: 6px;
      border-radius: 3px;
      background: rgba(255, 255, 255, 0.3);
      outline: none;
    }
    
    .stats {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 15px;
      margin: 25px 0;
    }
    
    .stat {
      background: rgba(0, 0, 0, 0.3);
      padding: 20px 15px;
      border-radius: 12px;
      text-align: center;
    }
    
    .stat-value {
      font-size: 1.8rem;
      font-weight: bold;
      color: #ff6b35;
      margin-bottom: 8px;
    }
    
    .stat-label {
      font-size: 0.9rem;
      opacity: 0.8;
    }
    
    .success {
      background: rgba(46, 204, 113, 0.3) !important;
      color: #2ecc71 !important;
    }
    
    .error {
      background: rgba(231, 76, 60, 0.3) !important;
      color: #e74c3c !important;
    }
    
    .streaming {
      background: rgba(52, 152, 219, 0.3) !important;
      color: #3498db !important;
    }
    
    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.6; }
    }
    
    .streaming {
      animation: pulse 2s ease-in-out infinite;
    }
    
    .visualizer {
      margin: 25px 0;
      height: 60px;
      background: rgba(0, 0, 0, 0.3);
      border-radius: 10px;
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: hidden;
    }
    
    .wave {
      width: 3px;
      background: linear-gradient(to top, #ff6b35, #f7931e);
      margin: 0 1px;
      border-radius: 1px;
      transition: height 0.1s ease;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>üìª FM Radio - PCM Player</h1>
    
    <div class="status" id="statusDisplay">
      üéß Ready for live radio
    </div>
    
    <div>
      <button class="btn" id="connectBtn" onclick="startRadio()">
        üéµ Connect to Radio
      </button>
      <button class="btn stop" id="stopBtn" onclick="stopRadio()" style="display: none;">
        ‚èπÔ∏è Stop Radio
      </button>
    </div>
    
    <div class="audio-section" id="audioSection">
      <div class="play-controls">
        <button class="play-btn" id="playBtn" onclick="toggleAudio()">
          ‚ñ∂Ô∏è
        </button>
        
        <div class="volume-control">
          <span>üîä</span>
          <input type="range" id="volumeSlider" class="volume-slider" 
                 min="0" max="100" value="70" onchange="setVolume(this.value)">
          <span id="volumeDisplay">70%</span>
        </div>
      </div>
      
      <div class="visualizer" id="visualizer"></div>
    </div>
    
    <div class="stats">
      <div class="stat">
        <div class="stat-value" id="connectionStat">‚ùå</div>
        <div class="stat-label">Connection</div>
      </div>
      <div class="stat">
        <div class="stat-value" id="chunkStat">0</div>
        <div class="stat-label">Chunks</div>
      </div>
      <div class="stat">
        <div class="stat-value" id="dataStat">0 KB</div>
        <div class="stat-label">Data</div>
      </div>
      <div class="stat">
        <div class="stat-value" id="bufferStat">0%</div>
        <div class="stat-label">Buffer</div>
      </div>
    </div>
  </div>

  <script>
    // Audio variables
    let websocket = null;
    let audioContext = null;
    let gainNode = null;
    let isStreaming = false;
    let isPlaying = false;
    let chunkCount = 0;
    let totalBytes = 0;
    
    // Adaptive audio streaming system
    let audioQueue = [];
    let audioElement = null;
    let isBuffering = false;
    let bufferSize = 0;
    let nextPlayTime = 0;
    let audioScheduler = null;
    
    // Robust PCM buffer with automatic recovery
    let pcmBuffer = new Float32Array(0);
    let minBufferSize = 2400; // 50ms at 48kHz
    let targetBufferSize = 4800; // 100ms at 48kHz
    
    // Admin pause/resume detection with stream restart handling
    let streamState = 'active'; // 'active', 'paused', 'restarting'
    let lastAudioLevel = 0;
    let silenceThreshold = 0.001;
    let silenceDuration = 0;
    let maxSilenceBeforeReset = 500; // 0.5 seconds of silence
    let consecutiveAudioChunks = 0;
    let lastChunkTime = 0;
    
    // DOM elements
    const statusDisplay = document.getElementById('statusDisplay');
    const connectBtn = document.getElementById('connectBtn');
    const stopBtn = document.getElementById('stopBtn');
    const audioSection = document.getElementById('audioSection');
    const playBtn = document.getElementById('playBtn');
    const volumeSlider = document.getElementById('volumeSlider');
    const volumeDisplay = document.getElementById('volumeDisplay');
    const visualizer = document.getElementById('visualizer');
    const connectionStat = document.getElementById('connectionStat');
    const chunkStat = document.getElementById('chunkStat');
    const dataStat = document.getElementById('dataStat');
    const bufferStat = document.getElementById('bufferStat');

    // Initialize visualizer
    function createVisualizer() {
      visualizer.innerHTML = '';
      for (let i = 0; i < 40; i++) {
        const wave = document.createElement('div');
        wave.className = 'wave';
        wave.style.height = '5px';
        visualizer.appendChild(wave);
      }
    }

    // Animate visualizer based on audio data
    function animateVisualizer(audioData = null) {
      const waves = visualizer.querySelectorAll('.wave');
      
      if (audioData && isPlaying) {
        // Use actual audio data for visualization
        const step = Math.floor(audioData.length / waves.length);
        waves.forEach((wave, index) => {
          const dataIndex = index * step;
          const amplitude = Math.abs(audioData[dataIndex] || 0);
          const height = Math.min(amplitude * 60 + 5, 50);
          wave.style.height = height + 'px';
        });
      } else {
        // Random animation when not playing
        waves.forEach(wave => {
          const height = Math.random() * (isPlaying ? 30 : 10) + 5;
          wave.style.height = height + 'px';
          wave.style.opacity = isPlaying ? 0.9 : 0.3;
        });
      }
    }

    // Start radio
    async function startRadio() {
      try {
        updateStatus('üîß Initializing audio system...', 'streaming');
        
        // Create simple audio element approach
        audioElement = document.createElement('audio');
        audioElement.controls = false;
        audioElement.autoplay = true;
        audioElement.volume = 0.7;
        
        updateStatus('üåê Connecting to radio server...', 'streaming');
        
        // Connect to WebSocket
        await connectWebSocket();
        
        // Initialize streaming
        isStreaming = true;
        chunkCount = 0;
        totalBytes = 0;
        audioQueue = [];
        
        // Update UI
        connectBtn.style.display = 'none';
        stopBtn.style.display = 'inline-block';
        audioSection.style.display = 'block';
        
        createVisualizer();
        setInterval(() => animateVisualizer(), 100);
        
        updateStatus('‚úÖ Connected! Receiving audio...', 'success');
        
        console.log('üéß Simple audio streaming started');
        
      } catch (error) {
        console.error('‚ùå Failed to start radio:', error);
        updateStatus('‚ùå Failed to start: ' + error.message, 'error');
      }
    }

    // Connect to WebSocket
    function connectWebSocket() {
      return new Promise((resolve, reject) => {
        try {
          const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
          const wsUrl = protocol + '//' + window.location.host;
          
          console.log('üîó Connecting to:', wsUrl);
          
          websocket = new WebSocket(wsUrl);
          websocket.binaryType = 'arraybuffer';
          
          websocket.onopen = () => {
            console.log('‚úÖ WebSocket connected');
            connectionStat.textContent = '‚úÖ';
            resolve();
          };
          
          websocket.onmessage = async (event) => {
            if (isStreaming) {
              await handlePCMData(event.data);
            }
          };
          
          websocket.onclose = () => {
            console.log('‚ùå WebSocket disconnected');
            updateStatus('‚ùå Connection lost', 'error');
            connectionStat.textContent = '‚ùå';
          };
          
          websocket.onerror = (error) => {
            console.error('‚ùå WebSocket error:', error);
            updateStatus('‚ùå Connection failed', 'error');
            connectionStat.textContent = '‚ùå';
            reject(new Error('WebSocket connection failed'));
          };
          
        } catch (error) {
          console.error('‚ùå Failed to create WebSocket:', error);
          reject(error);
        }
      });
    }

    // Handle incoming PCM data - direct real-time processing
    async function handlePCMData(arrayBuffer) {
      chunkCount++;
      totalBytes += arrayBuffer.byteLength;
      
      // Update stats
      chunkStat.textContent = chunkCount;
      dataStat.textContent = formatBytes(totalBytes);
      bufferStat.textContent = 'üî¥ LIVE';
      
      console.log(`üì° Direct PCM chunk ${chunkCount}: ${arrayBuffer.byteLength} bytes`);
      
      // Process audio immediately for zero latency
      processIncomingAudio(arrayBuffer);
      
      // Animate visualizer
      if (isPlaying) {
        const pcmData = new Int16Array(arrayBuffer);
        const floatData = new Float32Array(pcmData.length);
        for (let i = 0; i < pcmData.length; i++) {
          floatData[i] = pcmData[i] / 32768.0;
        }
        animateVisualizer(floatData);
      }
      
      // Auto-enable play after receiving some data
      if (chunkCount === 2 && !isPlaying) {
        updateStatus('üéµ Ready! Click ‚ñ∂Ô∏è to hear live audio', 'success');
      }
    }

    // Process audio queue smoothly without breaking
    // Initialize global PCM buffer with automatic recovery
    window.pcmBuffer = new Float32Array(0);
    
    // Complete audio system reset for clean restart
    function resetAudioSystem() {
      try {
        console.log('üîß Resetting audio system...');
        
        // Stop current scheduling
        if (audioScheduler) {
          clearInterval(audioScheduler);
          audioScheduler = null;
        }
        
        // Clear all buffers
        window.pcmBuffer = new Float32Array(0);
        nextPlayTime = 0;
        
        // Reset audio context timing
        if (audioContext && audioContext.state === 'running') {
          nextPlayTime = audioContext.currentTime + 0.1; // Fresh start with small delay
        }
        
        // Reset stream state variables
        silenceDuration = 0;
        consecutiveAudioChunks = 0;
        lastAudioLevel = 0;
        
        // Restart scheduling if audio is playing
        if (isPlaying && audioContext && audioContext.state === 'running') {
          audioScheduler = setInterval(() => {
            if (isPlaying && window.pcmBuffer.length >= minBufferSize) {
              scheduleAudioPlayback();
            }
          }, 25);
        }
        
        console.log('‚úÖ Audio system reset complete');
        
      } catch (error) {
        console.error('‚ùå Audio reset error:', error);
      }
    }
    
    // Adaptive audio processing with stream restart detection
    function processIncomingAudio(pcmBufferData) {
      if (!audioContext || !gainNode || !isPlaying) return;
      
      try {
        const pcmData = new Int16Array(pcmBufferData);
        const currentTime = Date.now();
        
        // Convert to float with better precision
        const floatData = new Float32Array(pcmData.length);
        let maxAmplitude = 0;
        
        for (let i = 0; i < pcmData.length; i++) {
          floatData[i] = Math.max(-1, Math.min(1, pcmData[i] / 32768.0));
          maxAmplitude = Math.max(maxAmplitude, Math.abs(floatData[i]));
        }
        
        // Detect stream interruption and restart
        const timeSinceLastChunk = currentTime - lastChunkTime;
        lastChunkTime = currentTime;
        
        if (maxAmplitude < silenceThreshold) {
          // Silence detected
          silenceDuration += Math.min(timeSinceLastChunk, 100);
          consecutiveAudioChunks = 0;
          
          if (silenceDuration > maxSilenceBeforeReset && streamState !== 'paused') {
            console.log('üîá Stream paused - stopping audio scheduling');
            streamState = 'paused';
            
            // Stop all scheduled audio immediately
            if (audioScheduler) {
              clearInterval(audioScheduler);
              audioScheduler = null;
            }
            
            // Clear buffer to prevent stale audio
            window.pcmBuffer = new Float32Array(0);
            nextPlayTime = 0;
            
            updateStatus('‚è∏Ô∏è Admin paused - waiting for resume...', 'streaming');
          }
        } else {
          // Audio detected
          consecutiveAudioChunks++;
          
          // Check if we're resuming from pause
          if (streamState === 'paused' && consecutiveAudioChunks >= 2) {
            console.log('üîÑ Stream resumed - restarting audio system');
            streamState = 'restarting';
            
            // Complete system reset for clean restart
            await resetAudioSystem();
            
            streamState = 'active';
            updateStatus('ÔøΩ LIVE - Stream resumed successfully!', 'success');
          }
          
          silenceDuration = 0;
        }
        
        lastAudioLevel = maxAmplitude;
        
        // Only process audio if stream is active
        if (streamState === 'active') {
          // Add to continuous buffer
          const newBuffer = new Float32Array(window.pcmBuffer.length + floatData.length);
          newBuffer.set(window.pcmBuffer);
          newBuffer.set(floatData, window.pcmBuffer.length);
          window.pcmBuffer = newBuffer;
          
          // Start/continue playback
          scheduleAudioPlayback();
        }
        
        console.log(`üéµ Audio: ${floatData.length} samples, level: ${maxAmplitude.toFixed(4)}, state: ${streamState}`);
        
      } catch (error) {
        console.error('‚ùå Audio processing error:', error);
        resetAudioSystem();
      }
    }
    
    // Adaptive scheduling that prevents gaps and recovers automatically
    function scheduleAudioPlayback() {
      if (!audioContext || !isPlaying || window.pcmBuffer.length < minBufferSize) return;
      
      try {
        const currentTime = audioContext.currentTime;
        
        // Auto-recovery: reset timing if we're behind schedule
        if (nextPlayTime < currentTime) {
          nextPlayTime = currentTime + 0.05; // Small delay for stability
          console.log('üîÑ Audio timing reset for continuous playback');
        }
        
        // Play chunks while we have enough buffered data
        while (window.pcmBuffer.length >= targetBufferSize && nextPlayTime < currentTime + 0.5) {
          const chunk = window.pcmBuffer.slice(0, targetBufferSize);
          window.pcmBuffer = window.pcmBuffer.slice(targetBufferSize);
          
          // Create and schedule audio buffer
          const audioBuffer = audioContext.createBuffer(1, chunk.length, 48000);
          audioBuffer.getChannelData(0).set(chunk);
          
          const source = audioContext.createBufferSource();
          source.buffer = audioBuffer;
          source.connect(gainNode);
          
          source.start(nextPlayTime);
          nextPlayTime += audioBuffer.duration;
          
          console.log(`üéµ Scheduled audio chunk: ${chunk.length} samples at ${nextPlayTime.toFixed(3)}s`);
        }
        
      } catch (error) {
        console.error('‚ùå Audio scheduling error:', error);
        // Reset timing on error
        nextPlayTime = audioContext.currentTime + 0.05;
      }
    }

    // Toggle audio playback
    async function toggleAudio() {
      if (!isStreaming) {
        updateStatus('‚ùå Please connect to radio first', 'error');
        return;
      }
      
      try {
        if (isPlaying) {
          // Stop playing
          isPlaying = false;
          playBtn.textContent = '‚ñ∂Ô∏è';
          updateStatus('‚è∏Ô∏è Audio paused', 'success');
          
          // Stop scheduling
          if (audioScheduler) {
            clearInterval(audioScheduler);
            audioScheduler = null;
          }
          
          if (audioContext) {
            await audioContext.suspend();
          }
          
        } else {
          // Start playing - initialize Web Audio API
          if (!audioContext || audioContext.state === 'closed') {
            audioContext = new (window.AudioContext || window.webkitAudioContext)({
              sampleRate: 48000,
              latencyHint: 'interactive'
            });
            
            gainNode = audioContext.createGain();
            gainNode.connect(audioContext.destination);
            gainNode.gain.value = parseFloat(document.getElementById('volumeSlider').value) / 100;
            
            console.log('üéß Web Audio API initialized for real-time streaming');
          }
          
          if (audioContext.state === 'suspended') {
            await audioContext.resume();
          }
          
          // Reset timing and buffer for new session
          nextPlayTime = audioContext.currentTime + 0.1; // Small initial delay
          window.pcmBuffer = new Float32Array(0);
          
          // Reset stream state and detection system
          streamState = 'active';
          silenceDuration = 0;
          consecutiveAudioChunks = 0;
          lastAudioLevel = 0;
          lastChunkTime = Date.now();
          
          // Start continuous scheduling monitor
          if (audioScheduler) clearInterval(audioScheduler);
          audioScheduler = setInterval(() => {
            if (isPlaying && window.pcmBuffer.length >= minBufferSize) {
              scheduleAudioPlayback();
            }
          }, 25); // Check every 25ms for smooth playback
          
          isPlaying = true;
          playBtn.textContent = '‚è∏Ô∏è';
          updateStatus('üî¥ LIVE - Real-time audio streaming!', 'success');
        }
        
      } catch (error) {
        console.error('‚ùå Audio toggle error:', error);
        updateStatus('‚ùå Audio error: ' + error.message, 'error');
      }
    }

    // Set volume
    // Set volume for Web Audio API
    function setVolume(value) {
      const volume = value / 100;
      if (gainNode) {
        gainNode.gain.value = volume;
      }
      volumeDisplay.textContent = value + '%';
    }

    // Stop radio
    function stopRadio() {
      isStreaming = false;
      isPlaying = false;
      
      // Stop and cleanup audio context
      if (audioContext) {
        audioContext.suspend();
      }
      
      // Stop scheduling
      if (audioScheduler) {
        clearInterval(audioScheduler);
        audioScheduler = null;
      }
      
      // Clear buffers
      audioQueue = [];
      if (typeof window.pcmBuffer !== 'undefined') {
        window.pcmBuffer = new Float32Array(0);
      }
      nextPlayTime = 0;
      
      // Reset stream state and detection
      streamState = 'active';
      silenceDuration = 0;
      consecutiveAudioChunks = 0;
      lastAudioLevel = 0;
      lastChunkTime = 0;
      
      // Close WebSocket
      if (websocket) {
        websocket.close();
        websocket = null;
      }
      
      // Reset variables
      chunkCount = 0;
      totalBytes = 0;
      
      // Update UI
      connectBtn.style.display = 'inline-block';
      stopBtn.style.display = 'none';
      audioSection.style.display = 'none';
      playBtn.textContent = '‚ñ∂Ô∏è';
      
      updateStatus('‚èπÔ∏è Radio stopped');
      connectionStat.textContent = '‚ùå';
      
      console.log('‚èπÔ∏è Real-time radio streaming stopped');
    }

    // Update status display
    function updateStatus(message, type = '') {
      statusDisplay.textContent = message;
      statusDisplay.className = 'status';
      if (type) {
        statusDisplay.classList.add(type);
      }
    }

    // Format bytes for display
    function formatBytes(bytes) {
      if (bytes === 0) return '0 B';
      const k = 1024;
      const sizes = ['B', 'KB', 'MB'];
      const i = Math.floor(Math.log(bytes) / Math.log(k));
      return Math.round(bytes / Math.pow(k, i)) + ' ' + sizes[i];
    }

    // Cleanup on page unload
    window.addEventListener('beforeunload', () => {
      if (websocket) websocket.close();
      if (audioContext) audioContext.close();
    });

    // Initialize
    window.addEventListener('load', () => {
      console.log('üìª PCM FM Radio Player loaded');
    });
  </script>
</body>
</html>
