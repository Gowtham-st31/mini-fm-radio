


<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>FM Radio - HD PCM Player</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      text-align: center;
      padding: 20px;
      margin: 0;
      min-height: 100vh;
    }
    
    .container {
      max-width: 600px;
      margin: 0 auto;
      background: rgba(255, 255, 255, 0.1);
      padding: 40px;
      border-radius: 20px;
      backdrop-filter: blur(10px);
    }
    
    h1 {
      color: #ff6b35;
      margin-bottom: 30px;
      font-size: 2.5rem;
    }
    
    .status {
      padding: 20px;
      margin: 20px 0;
      background: rgba(0, 0, 0, 0.3);
      border-radius: 15px;
      font-size: 1.2rem;
      min-height: 60px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    .btn {
      background: linear-gradient(45deg, #ff6b35, #f7931e);
      color: white;
      border: none;
      padding: 18px 35px;
      font-size: 1.2rem;
      border-radius: 30px;
      cursor: pointer;
      margin: 15px;
      min-width: 200px;
      font-weight: 600;
    }
    
    .btn:disabled {
      background: #666;
      cursor: not-allowed;
    }
    
    .btn.stop {
      background: linear-gradient(45deg, #e74c3c, #c0392b);
    }
    
    .audio-section {
      margin: 30px 0;
      padding: 25px;
      background: rgba(0, 0, 0, 0.2);
      border-radius: 15px;
      display: none;
    }
    
    .play-controls {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 25px;
      margin: 25px 0;
    }
    
    .play-btn {
      background: linear-gradient(45deg, #27ae60, #2ecc71);
      color: white;
      border: none;
      width: 80px;
      height: 80px;
      border-radius: 50%;
      font-size: 2rem;
      cursor: pointer;
    }
    
    .volume-control {
      display: flex;
      align-items: center;
      gap: 10px;
    }
    
    .volume-slider {
      width: 120px;
      height: 6px;
      border-radius: 3px;
      background: rgba(255, 255, 255, 0.3);
      outline: none;
    }
    
    .stats {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 15px;
      margin: 25px 0;
    }
    
    .stat {
      background: rgba(0, 0, 0, 0.3);
      padding: 20px 15px;
      border-radius: 12px;
      text-align: center;
    }
    
    .stat-value {
      font-size: 1.8rem;
      font-weight: bold;
      color: #ff6b35;
      margin-bottom: 8px;
    }
    
    .stat-label {
      font-size: 0.9rem;
      opacity: 0.8;
    }
    
    .success {
      background: rgba(46, 204, 113, 0.3) !important;
      color: #2ecc71 !important;
    }
    
    .error {
      background: rgba(231, 76, 60, 0.3) !important;
      color: #e74c3c !important;
    }
    
    .streaming {
      background: rgba(52, 152, 219, 0.3) !important;
      color: #3498db !important;
    }
    
    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.6; }
    }
    
    .streaming {
      animation: pulse 2s ease-in-out infinite;
    }
    
    .visualizer {
      margin: 25px 0;
      height: 60px;
      background: rgba(0, 0, 0, 0.3);
      border-radius: 10px;
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: hidden;
    }
    
    .wave {
      width: 3px;
      background: linear-gradient(to top, #ff6b35, #f7931e);
      margin: 0 1px;
      border-radius: 1px;
      transition: height 0.1s ease;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>üìª FM Radio - HD PCM Player</h1>
    
    <div class="status" id="statusDisplay">
      üéß Ready for live radio
    </div>
    
    <div class="status" id="backgroundStatus" style="display: none; background: rgba(76, 175, 80, 0.3); color: #4CAF50; font-size: 1rem; padding: 15px;">
      üéµ Background Audio Active - Radio continues playing when you switch tabs!
    </div>
    
    <div>
      <button class="btn" id="connectBtn" onclick="startRadio()">
        üéµ Connect to Radio
      </button>
      <button class="btn stop" id="stopBtn" onclick="stopRadio()" style="display: none;">
        ‚èπÔ∏è Stop Radio
      </button>
    </div>
    
    <div class="audio-section" id="audioSection">
      <div class="play-controls">
        <button class="play-btn" id="playBtn" onclick="toggleAudio()">
          ‚ñ∂Ô∏è
        </button>
        
        <div class="volume-control">
          <span>üîä</span>
          <input type="range" id="volumeSlider" class="volume-slider" 
                 min="0" max="100" value="70" onchange="setVolume(this.value)">
          <span id="volumeDisplay">70%</span>
        </div>
      </div>
      
      <div class="visualizer" id="visualizer"></div>
    </div>
    
    <div class="stats">
      <div class="stat">
        <div class="stat-value" id="connectionStat">‚ùå</div>
        <div class="stat-label">Connection</div>
      </div>
      <div class="stat">
        <div class="stat-value" id="chunkStat">0</div>
        <div class="stat-label">Chunks</div>
      </div>
      <div class="stat">
        <div class="stat-value" id="dataStat">0 KB</div>
        <div class="stat-label">Data</div>
      </div>
      <div class="stat">
        <div class="stat-value" id="bufferStat">0%</div>
        <div class="stat-label">Buffer</div>
      </div>
    </div>
  </div>

  <script>
    // Audio variables
    let websocket = null;
    let audioContext = null;
    let gainNode = null;
    let isStreaming = false;
    let isPlaying = false;
    let chunkCount = 0;
    let totalBytes = 0;
    
    // Simple continuous audio approach with HD quality settings
    let audioQueue = [];
    let currentSource = null;
    let sampleRate = 48000; // High-quality sample rate
    let scheduleAheadTime = 0.05; // Reduced for lower latency, better quality
    let nextNoteTime = 0.0;
    
    // HD Audio quality settings
    let audioBufferSize = 4096; // Larger buffer for better quality
    let qualityMode = 'hd'; // HD mode flag
    
    // Admin pause/resume detection with stricter thresholds
    window.adminPaused = false;
    window.pauseStartTime = 0;
    window.silenceCount = 0;
    window.audioCount = 0;
    
    // Auto-recovery system for audio breaking
    window.lastAudioTime = 0;
    window.audioBreakDetected = false;
    window.consecutiveGoodChunks = 0;
    
    // Admin stop/start detection (different from pause/resume)
    window.adminStopped = false;
    window.lastChunkTime = 0;
    window.noAudioTimeout = null;
    
    // Enhanced auto-recovery system
    window.autoRecoveryInterval = null;
    window.severeBreakCount = 0;
    window.lastGoodAudioTime = 0;
    
    // Admin page visibility detection
    window.adminPageLeft = false;
    window.lastChunkReceived = 0;
    window.noChunksTimeout = null;
    
    // User page visibility detection for background audio
    window.userPageHidden = false;
    window.backgroundKeepAlive = null;
    window.wakeLock = null;
    window.backgroundAudioActive = false;
    
    // DOM elements
    const statusDisplay = document.getElementById('statusDisplay');
    const backgroundStatus = document.getElementById('backgroundStatus');
    const connectBtn = document.getElementById('connectBtn');
    const stopBtn = document.getElementById('stopBtn');
    const audioSection = document.getElementById('audioSection');
    const playBtn = document.getElementById('playBtn');
    const volumeSlider = document.getElementById('volumeSlider');
    const volumeDisplay = document.getElementById('volumeDisplay');
    const visualizer = document.getElementById('visualizer');
    const connectionStat = document.getElementById('connectionStat');
    const chunkStat = document.getElementById('chunkStat');
    const dataStat = document.getElementById('dataStat');
    const bufferStat = document.getElementById('bufferStat');

    // Initialize visualizer
    function createVisualizer() {
      visualizer.innerHTML = '';
      for (let i = 0; i < 40; i++) {
        const wave = document.createElement('div');
        wave.className = 'wave';
        wave.style.height = '5px';
        visualizer.appendChild(wave);
      }
    }

    // Animate visualizer based on audio data
    function animateVisualizer(audioData = null) {
      const waves = visualizer.querySelectorAll('.wave');
      
      if (audioData && isPlaying) {
        // Use actual audio data for visualization
        const step = Math.floor(audioData.length / waves.length);
        waves.forEach((wave, index) => {
          const dataIndex = index * step;
          const amplitude = Math.abs(audioData[dataIndex] || 0);
          const height = Math.min(amplitude * 60 + 5, 50);
          wave.style.height = height + 'px';
        });
      } else {
        // Random animation when not playing
        waves.forEach(wave => {
          const height = Math.random() * (isPlaying ? 30 : 10) + 5;
          wave.style.height = height + 'px';
          wave.style.opacity = isPlaying ? 0.9 : 0.3;
        });
      }
    }

    // Start radio
    async function startRadio() {
      try {
        updateStatus('üîß Initializing Web Audio API...', 'streaming');
        
        // Create Web Audio context with HD settings
        audioContext = new (window.AudioContext || window.webkitAudioContext)({
          sampleRate: sampleRate,
          latencyHint: 'interactive' // Optimized for real-time audio
        });
        
        await audioContext.resume();
        
        // Create gain node for volume control with HD processing
        gainNode = audioContext.createGain();
        
        // Add audio processing for better quality
        const compressor = audioContext.createDynamicsCompressor();
        compressor.threshold.setValueAtTime(-24, audioContext.currentTime);
        compressor.knee.setValueAtTime(30, audioContext.currentTime);
        compressor.ratio.setValueAtTime(12, audioContext.currentTime);
        compressor.attack.setValueAtTime(0.003, audioContext.currentTime);
        compressor.release.setValueAtTime(0.25, audioContext.currentTime);
        
        // Create EQ for better sound
        const lowShelf = audioContext.createBiquadFilter();
        lowShelf.type = 'lowshelf';
        lowShelf.frequency.setValueAtTime(320, audioContext.currentTime);
        lowShelf.gain.setValueAtTime(2, audioContext.currentTime);
        
        const highShelf = audioContext.createBiquadFilter();
        highShelf.type = 'highshelf';
        highShelf.frequency.setValueAtTime(3200, audioContext.currentTime);
        highShelf.gain.setValueAtTime(1, audioContext.currentTime);
        
        // Connect the audio chain: gainNode -> EQ -> compressor -> destination
        gainNode.connect(lowShelf);
        lowShelf.connect(highShelf);
        highShelf.connect(compressor);
        compressor.connect(audioContext.destination);
        gainNode.gain.value = 0.8; // Slightly higher for HD quality
        
        updateStatus('üåê Connecting to radio server...', 'streaming');
        
        // Connect to WebSocket
        await connectWebSocket();
        
        // Initialize streaming
        isStreaming = true;
        chunkCount = 0;
        totalBytes = 0;
        audioQueue = [];
        nextNoteTime = 0;
        
        // Start continuous auto-recovery monitoring
        startAutoRecoveryMonitor();
        
        // Update UI
        connectBtn.style.display = 'none';
        stopBtn.style.display = 'inline-block';
        audioSection.style.display = 'block';
        
        createVisualizer();
        setInterval(() => animateVisualizer(), 100);
        
        updateStatus('‚úÖ Connected! Receiving HD audio...', 'success');
        
        console.log('üéß PCM radio streaming started');
        
      } catch (error) {
        console.error('‚ùå Failed to start radio:', error);
        updateStatus('‚ùå Failed to start: ' + error.message, 'error');
      }
    }

    // Connect to WebSocket
    function connectWebSocket() {
      return new Promise((resolve, reject) => {
        try {
          const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
          const wsUrl = protocol + '//' + window.location.host;
          
          console.log('üîó Connecting to:', wsUrl);
          
          websocket = new WebSocket(wsUrl);
          websocket.binaryType = 'arraybuffer';
          
          websocket.onopen = () => {
            console.log('‚úÖ WebSocket connected');
            connectionStat.textContent = '‚úÖ';
            resolve();
          };
          
          websocket.onmessage = async (event) => {
            if (isStreaming) {
              await handlePCMData(event.data);
            }
          };
          
          websocket.onclose = () => {
            console.log('‚ùå WebSocket disconnected');
            updateStatus('‚ùå Connection lost', 'error');
            connectionStat.textContent = '‚ùå';
          };
          
          websocket.onerror = (error) => {
            console.error('‚ùå WebSocket error:', error);
            updateStatus('‚ùå Connection failed', 'error');
            connectionStat.textContent = '‚ùå';
            reject(new Error('WebSocket connection failed'));
          };
          
        } catch (error) {
          console.error('‚ùå Failed to create WebSocket:', error);
          reject(error);
        }
      });
    }

    // Handle incoming PCM data with automatic break detection
    async function handlePCMData(arrayBuffer) {
      chunkCount++;
      totalBytes += arrayBuffer.byteLength;
      
      // Update stats
      chunkStat.textContent = chunkCount;
      dataStat.textContent = formatBytes(totalBytes);
      bufferStat.textContent = Math.min(audioQueue.length * 5, 100) + '%';
      
      const currentTime = Date.now();
      
      // Clear any pending "no audio" timeout since we just received audio
      if (window.noAudioTimeout) {
        clearTimeout(window.noAudioTimeout);
        window.noAudioTimeout = null;
      }
      
      // Clear any "no chunks" timeout since we just received a chunk
      if (window.noChunksTimeout) {
        clearTimeout(window.noChunksTimeout);
        window.noChunksTimeout = null;
      }
      
      // Track when we last received a chunk for admin page detection
      window.lastChunkReceived = currentTime;
      
      // Set timeout to detect if admin left the page (no chunks for 3+ seconds)
      window.noChunksTimeout = setTimeout(() => {
        if (!window.adminPageLeft && isStreaming) {
          window.adminPageLeft = true;
          console.log('üì± Admin appears to have LEFT the page (3+ sec no chunks)');
          updateStatus('üì± Admin left page - audio paused...', 'streaming');
          
          // Don't clear audio immediately - wait for admin to return
          // Just mark the state for better handling
        }
      }, 3000);
      
      // Admin stop/start detection - if no audio for 2+ seconds, consider admin stopped
      window.lastChunkTime = currentTime;
      window.noAudioTimeout = setTimeout(() => {
        if (!window.adminStopped && isStreaming) {
          window.adminStopped = true;
          console.log('üõë Admin appears to have STOPPED streaming (2+ sec silence)');
          updateStatus('üõë Admin stopped - waiting for restart...', 'error');
          
          // Clear stale audio when admin stops
          audioQueue = [];
          if (audioContext && isPlaying) {
            nextNoteTime = audioContext.currentTime + 0.1;
          }
        }
      }, 2000);
      
      // Detect admin return to page after leaving (fresh chunks after long absence)
      if (window.adminPageLeft) {
        window.adminPageLeft = false;
        console.log('üì± Admin RETURNED to page - doing PAGE RETURN RESET');
        
        // Page return reset - similar to restart but gentler
        audioQueue = audioQueue.slice(-2); // Keep only 2 most recent chunks
        
        // Reset timing and detection systems
        window.lastAudioTime = currentTime;
        window.lastGoodAudioTime = currentTime;
        window.audioBreakDetected = false;
        window.consecutiveGoodChunks = 0;
        window.adminPaused = false;
        window.pauseStartTime = 0;
        window.silenceCount = 0;
        window.audioCount = 0;
        window.severeBreakCount = 0; // Reset severe break counter
        
        if (audioContext && isPlaying) {
          nextNoteTime = audioContext.currentTime + 0.03; // Quick sync
        }
        
        updateStatus('üì± Admin returned - syncing audio...', 'success');
        console.log('üì± PAGE RETURN RESET: Audio synced for admin return');
      }
      
      // Detect admin restart after stop (fresh audio after long silence)
      if (window.adminStopped) {
        window.adminStopped = false;
        console.log('üîÑ Admin RESTARTED streaming - doing COMPLETE RESET');
        
        // COMPLETE RESET for admin restart (much more aggressive than pause/resume)
        audioQueue = []; // Clear ALL old audio
        chunkCount = 1; // Reset chunk counter for fresh start
        totalBytes = arrayBuffer.byteLength; // Reset data counter
        
        // Reset ALL timing and detection systems
        window.lastAudioTime = currentTime;
        window.audioBreakDetected = false;
        window.consecutiveGoodChunks = 0;
        window.adminPaused = false;
        window.pauseStartTime = 0;
        window.silenceCount = 0;
        window.audioCount = 0;
        
        if (audioContext && isPlaying) {
          nextNoteTime = audioContext.currentTime + 0.05; // Fresh timing start
        }
        
        updateStatus('üî¥ LIVE - Admin restarted with fresh sync!', 'success');
        console.log('üí• COMPLETE RESET: All systems cleared for admin restart');
      }
      
      // Detect audio breaks - if chunks are coming too slowly or irregularly
      if (window.lastAudioTime > 0) {
        const timeDiff = currentTime - window.lastAudioTime;
        
        // If chunk arrives more than 200ms late, it might cause breaking
        if (timeDiff > 200) {
          window.audioBreakDetected = true;
          window.consecutiveGoodChunks = 0;
          
          console.log(`‚ö†Ô∏è Audio break detected! Chunk delayed by ${timeDiff}ms - auto-recovery in 1 sec`);
          
          // Immediate recovery - clear buffers and reset timing
          audioQueue = audioQueue.slice(-2); // Keep only 2 most recent chunks
          
          if (audioContext && isPlaying) {
            nextNoteTime = audioContext.currentTime + 0.05; // Quick restart
          }
          
          updateStatus('ÔøΩ Auto-recovering from audio break...', 'streaming');
          
          // Mark recovery complete after 1 second
          setTimeout(() => {
            if (window.consecutiveGoodChunks >= 3) {
              window.audioBreakDetected = false;
              updateStatus('‚úÖ Audio recovered - streaming smoothly!', 'success');
              console.log('‚úÖ Auto-recovery complete - audio stable');
            }
          }, 1000);
        } else if (timeDiff < 150) {
          // Good timing - increment recovery counter
          window.consecutiveGoodChunks++;
          if (window.audioBreakDetected && window.consecutiveGoodChunks >= 5) {
            window.audioBreakDetected = false;
            updateStatus('üî¥ LIVE - Audio recovered!', 'success');
            console.log('üéµ Audio break resolved - back to normal streaming');
          }
        }
      }
      
      window.lastAudioTime = currentTime;
      window.lastGoodAudioTime = currentTime; // Track last truly good audio
      
      console.log(`üì° PCM chunk ${chunkCount}: ${arrayBuffer.byteLength} bytes, queue: ${audioQueue.length}, delay: ${window.lastAudioTime ? currentTime - window.lastAudioTime : 0}ms`);
      
      // Convert ArrayBuffer to Float32Array for HD audio processing
      const pcmData = new Int16Array(arrayBuffer);
      const floatData = new Float32Array(pcmData.length);
      
      // Enhanced int16 to float32 conversion with better precision for HD quality
      let maxAmplitude = 0;
      for (let i = 0; i < pcmData.length; i++) {
        // More precise conversion with dithering for HD quality
        let sample = pcmData[i] / 32768.0;
        
        // Add subtle dithering to reduce quantization noise
        const dither = (Math.random() - 0.5) * (1.0 / 32768.0);
        sample += dither * 0.1;
        
        // Soft limiting to prevent clipping while preserving dynamics
        if (sample > 0.95) sample = 0.95 + (sample - 0.95) * 0.1;
        if (sample < -0.95) sample = -0.95 + (sample + 0.95) * 0.1;
        
        floatData[i] = sample;
        maxAmplitude = Math.max(maxAmplitude, Math.abs(sample));
      }
      
      // Much more robust admin pause/resume detection with immediate clearing
      if (maxAmplitude < 0.0001) { // Much stricter silence threshold
        window.silenceCount++;
        window.audioCount = 0; // Reset audio counter
        
        // Only trigger pause detection after consistent silence (5+ chunks for faster detection)
        if (window.silenceCount > 5 && !window.adminPaused) {
          window.adminPaused = true;
          window.pauseStartTime = Date.now();
          console.log('üîá Admin DEFINITELY paused - detected after ' + window.silenceCount + ' silent chunks');
          
          // IMMEDIATELY clear all audio buffers when admin pauses
          audioQueue = [];
          if (audioContext && isPlaying) {
            nextNoteTime = audioContext.currentTime + 0.1;
          }
          
          updateStatus('‚è∏Ô∏è Admin paused - buffers cleared!', 'streaming');
        }
      } else {
        window.audioCount++;
        window.silenceCount = 0; // Reset silence counter
        
        // Audio detected - check for resume with IMMEDIATE aggressive clearing
        if (window.adminPaused && window.audioCount > 1) { // Faster resume detection (only 1 audio chunk needed)
          window.adminPaused = false;
          const pauseDuration = Date.now() - window.pauseStartTime;
          
          console.log('üîÑ Admin DEFINITELY resumed after ' + pauseDuration + 'ms - AGGRESSIVE CLEAR');
          
          // ALWAYS do aggressive clear on admin resume regardless of duration
          audioQueue = []; // Clear ALL old audio
          
          if (audioContext && isPlaying) {
            nextNoteTime = audioContext.currentTime + 0.05; // Very quick restart
          }
          
          // Reset ALL counters and detection systems
          window.pauseStartTime = 0;
          window.silenceCount = 0;
          window.audioCount = 0;
          window.audioBreakDetected = false;
          window.consecutiveGoodChunks = 0;
          window.lastAudioTime = Date.now();
          
          updateStatus('üî¥ LIVE - Admin resumed with fresh buffers!', 'success');
          console.log('üí• AGGRESSIVE CLEAR: All buffers cleared for admin resume');
        }
      }
      
      // Add to audio queue (with aggressive filtering during admin pause/resume)
      if (window.adminPaused) {
        // During admin pause, don't add any audio to prevent stale data
        console.log('‚è∏Ô∏è Admin paused - rejecting audio chunk');
      } else if (window.audioBreakDetected) {
        // During recovery, keep queue very small
        if (audioQueue.length < 2) {
          audioQueue.push(floatData);
        }
      } else {
        // Normal operation - but always check if we need immediate clear
        audioQueue.push(floatData);
      }
      
      // Animate visualizer with actual audio data
      if (isPlaying) {
        animateVisualizer(floatData);
      }
      
      // Auto-enable play after receiving some data
      if (chunkCount === 2 && !isPlaying) {
        updateStatus('üéµ Ready! Click ‚ñ∂Ô∏è to hear audio', 'success');
      }
      
      // Keep queue optimized for HD quality (smaller, more responsive)
      if (audioQueue.length > 12) {
        console.log('üóëÔ∏è HD Queue optimization - keeping only recent high-quality audio');
        audioQueue = audioQueue.slice(-8); // Smaller queue for better quality
      }
    }

    // Reset audio timing for smooth restart after admin pause
    function resetAudioTiming() {
      if (!audioContext || !isPlaying) return;
      
      try {
        console.log('üîß Resetting audio timing...');
        
        // Clear existing queue to prevent stale audio
        audioQueue = [];
        
        // Reset timing to current time + small delay
        nextNoteTime = audioContext.currentTime + 0.1;
        
        console.log('‚úÖ Audio timing reset complete');
        
      } catch (error) {
        console.error('‚ùå Timing reset error:', error);
      }
    }

    // Enhanced scheduling with more aggressive break recovery
    function scheduleAudio() {
      const currentTime = audioContext.currentTime;
      
      // Super aggressive break detection during scheduling
      if (nextNoteTime < currentTime - 0.2) {
        console.log('üö® SEVERE audio timing break detected - IMMEDIATE RECOVERY!');
        
        // Immediate recovery instead of waiting for monitoring
        forceAudioReset('Severe timing break during scheduling');
        
      } else if (nextNoteTime < currentTime - 0.05) {
        console.log('üîÑ Minor audio timing lag - quick catch up');
        nextNoteTime = currentTime + 0.01; // Very quick catch up
      }
      
      // Schedule audio chunks with HD quality processing
      let scheduled = 0;
      while (nextNoteTime < currentTime + scheduleAheadTime && audioQueue.length > 0 && scheduled < 3) {
        playAudioAtTime(nextNoteTime);
        scheduled++;
      }
      
      // Update good audio time when we successfully schedule
      if (scheduled > 0) {
        window.lastGoodAudioTime = Date.now();
      }
      
      // Continue scheduling if playing
      if (isPlaying) {
        requestAnimationFrame(scheduleAudio);
      }
    }

    // Play single audio chunk at specific time with HD quality
    function playAudioAtTime(time) {
      if (audioQueue.length === 0) return;
      
      const audioData = audioQueue.shift();
      
      try {
        // Create high-quality audio buffer
        const audioBuffer = audioContext.createBuffer(1, audioData.length, sampleRate);
        const channelData = audioBuffer.getChannelData(0);
        
        // Apply windowing to reduce clicks/pops for better quality
        const windowSize = Math.min(64, audioData.length / 4);
        const windowedData = new Float32Array(audioData.length);
        
        for (let i = 0; i < audioData.length; i++) {
          let sample = audioData[i];
          
          // Apply Hann window at edges for smooth transitions
          if (i < windowSize) {
            const windowVal = 0.5 * (1 - Math.cos(2 * Math.PI * i / (2 * windowSize)));
            sample *= windowVal;
          } else if (i >= audioData.length - windowSize) {
            const windowVal = 0.5 * (1 - Math.cos(2 * Math.PI * (audioData.length - i) / (2 * windowSize)));
            sample *= windowVal;
          }
          
          windowedData[i] = sample;
        }
        
        channelData.set(windowedData);
        
        // Create and configure HD source
        const source = audioContext.createBufferSource();
        source.buffer = audioBuffer;
        
        // Add subtle interpolation for smoother playback
        source.connect(gainNode);
        
        // Schedule playback with precision timing
        if (time < audioContext.currentTime) {
          time = audioContext.currentTime + 0.001; // Minimal delay for HD quality
        }
        
        source.start(time);
        
        // Update next time with precise calculation
        nextNoteTime = time + audioBuffer.duration;
        
        console.log(`üéµ HD Audio scheduled at ${time.toFixed(4)}s, next: ${nextNoteTime.toFixed(4)}s, queue: ${audioQueue.length}`);
        
      } catch (error) {
        console.error('‚ùå HD Audio play error:', error);
      }
    }

    // Continuous auto-recovery monitoring system
    function startAutoRecoveryMonitor() {
      // Clear any existing monitor
      if (window.autoRecoveryInterval) {
        clearInterval(window.autoRecoveryInterval);
      }
      
      window.autoRecoveryInterval = setInterval(() => {
        if (!isStreaming || !isPlaying) return;
        
        const currentTime = Date.now();
        const timeSinceLastAudio = currentTime - window.lastGoodAudioTime;
        const timeSinceLastChunk = currentTime - window.lastChunkTime;
        const timeSinceChunkReceived = currentTime - window.lastChunkReceived;
        
        // Detect various types of breaks and fix them proactively
        if (timeSinceLastAudio > 500 && audioQueue.length < 2 && !window.adminPageLeft) {
          console.log('üîß AUTO-RECOVERY: Audio starving detected - forcing reset');
          forceAudioReset('Audio starvation detected');
          
        } else if (timeSinceLastChunk > 1000 && !window.adminPageLeft) {
          console.log('üîß AUTO-RECOVERY: No chunks for 1+ sec - forcing reset');
          forceAudioReset('Chunk starvation detected');
          
        } else if (timeSinceChunkReceived > 5000 && !window.adminPageLeft) {
          // Admin might have left page but timeout didn't trigger yet
          console.log('üîß AUTO-RECOVERY: Admin likely left page - gentle reset');
          window.adminPageLeft = true;
          updateStatus('üì± Admin left page - waiting for return...', 'streaming');
          
        } else if (audioQueue.length > 10) {
          console.log('üîß AUTO-RECOVERY: Queue overflow - HD optimization');
          audioQueue = audioQueue.slice(-4); // Keep fewer chunks for HD quality
          if (audioContext && isPlaying) {
            nextNoteTime = audioContext.currentTime + 0.02; // Faster restart for HD
          }
          
        } else if (nextNoteTime < audioContext.currentTime - 0.3 && !window.adminPageLeft) {
          console.log('üîß AUTO-RECOVERY: Severe timing drift - forcing reset');
          forceAudioReset('Severe timing drift');
          window.severeBreakCount++;
          
          // If we get too many severe breaks, simulate admin restart
          if (window.severeBreakCount >= 3) {
            console.log('üö® MULTIPLE SEVERE BREAKS - Simulating admin restart');
            simulateAdminRestart();
            window.severeBreakCount = 0;
          }
        }
        
      }, 250); // Check every 250ms for proactive recovery
    }
    
    // Force immediate audio reset (like admin restart but without waiting)
    function forceAudioReset(reason) {
      console.log(`üí• FORCE RESET: ${reason}`);
      
      // Complete audio system reset
      audioQueue = [];
      window.audioBreakDetected = false;
      window.consecutiveGoodChunks = 0;
      window.adminPaused = false;
      window.silenceCount = 0;
      window.audioCount = 0;
      
      if (audioContext && isPlaying) {
        nextNoteTime = audioContext.currentTime + 0.02; // Very quick restart
      }
      
      updateStatus('üîß Auto-recovery: ' + reason, 'streaming');
      
      // Reset tracking
      window.lastGoodAudioTime = Date.now();
      window.lastAudioTime = Date.now();
    }
    
    // Simulate admin restart for severe cases
    function simulateAdminRestart() {
      console.log('üîÑ SIMULATING ADMIN RESTART for recovery');
      
      // Reset all counters as if admin restarted
      chunkCount = 0;
      totalBytes = 0;
      audioQueue = [];
      
      // Reset all detection systems
      window.adminPaused = false;
      window.adminStopped = false;
      window.pauseStartTime = 0;
      window.silenceCount = 0;
      window.audioCount = 0;
      window.lastAudioTime = Date.now();
      window.lastGoodAudioTime = Date.now();
      window.lastChunkTime = Date.now();
      window.audioBreakDetected = false;
      window.consecutiveGoodChunks = 0;
      
      if (audioContext && isPlaying) {
        nextNoteTime = audioContext.currentTime + 0.05;
      }
      
      updateStatus('üîÑ Simulated restart - fresh sync!', 'success');
      console.log('üí• SIMULATED RESTART COMPLETE');
    }

    // Toggle audio playback
    async function toggleAudio() {
      if (!isStreaming) {
        updateStatus('‚ùå Please connect to radio first', 'error');
        return;
      }
      
      try {
        if (isPlaying) {
          // Stop playing
          isPlaying = false;
          playBtn.textContent = '‚ñ∂Ô∏è';
          
          // Stop background audio mode if active
          if (window.backgroundAudioActive) {
            stopBackgroundAudioMode();
          }
          
          updateStatus('‚è∏Ô∏è Audio paused', 'success');
          
        } else {
          // Start playing with minimal disruption
          if (audioContext.state === 'suspended') {
            await audioContext.resume();
          }
          
          isPlaying = true;
          
          // Much gentler reset - don't clear everything unless necessary
          if (audioQueue.length > 10) {
            audioQueue = audioQueue.slice(-5); // Keep only recent audio
          }
          
          nextNoteTime = audioContext.currentTime + 0.1; // Quick start
          
          // Reset all detection systems including auto-recovery
          window.adminPaused = false;
          window.adminStopped = false;
          window.adminPageLeft = false;
          window.pauseStartTime = 0;
          window.silenceCount = 0;
          window.audioCount = 0;
          window.lastAudioTime = Date.now();
          window.lastChunkTime = Date.now();
          window.lastGoodAudioTime = Date.now();
          window.lastChunkReceived = Date.now();
          window.audioBreakDetected = false;
          window.consecutiveGoodChunks = 0;
          window.severeBreakCount = 0;
          
          // Clear any pending timeouts
          if (window.noAudioTimeout) {
            clearTimeout(window.noAudioTimeout);
            window.noAudioTimeout = null;
          }
          
          if (window.noChunksTimeout) {
            clearTimeout(window.noChunksTimeout);
            window.noChunksTimeout = null;
          }
          
          // Start monitoring system
          startAutoRecoveryMonitor();
          
          playBtn.textContent = '‚è∏Ô∏è';
          
          // If user is on a different tab, immediately start background mode
          if (document.hidden) {
            startBackgroundAudioMode();
          } else {
            updateStatus('üéµ Playing HD audio with auto-recovery!', 'success');
          }
          
          console.log('üéß HD Audio playback started with break detection enabled');
          
          // Start the audio scheduling loop
          scheduleAudio();
        }
        
      } catch (error) {
        console.error('‚ùå Audio toggle error:', error);
        updateStatus('‚ùå Audio error: ' + error.message, 'error');
      }
    }

    // Set volume
    function setVolume(value) {
      const volume = value / 100;
      if (gainNode) {
        gainNode.gain.value = volume;
      }
      volumeDisplay.textContent = value + '%';
    }

    // Stop radio
    function stopRadio() {
      isStreaming = false;
      isPlaying = false;
      isProcessingAudio = false;
      
      // Clear buffer
      audioQueue = [];
      
      // Close Web Audio Context
      if (audioContext) {
        audioContext.close();
        audioContext = null;
      }
      
      // Close WebSocket
      if (websocket) {
        websocket.close();
      }
      
      // Reset variables
      gainNode = null;
      chunkCount = 0;
      totalBytes = 0;
      
      // Reset all detection systems
      window.adminPaused = false;
      window.adminStopped = false;
      window.adminPageLeft = false;
      window.pauseStartTime = 0;
      window.silenceCount = 0;
      window.audioCount = 0;
      window.lastAudioTime = 0;
      window.lastChunkTime = 0;
      window.lastChunkReceived = 0;
      window.audioBreakDetected = false;
      window.consecutiveGoodChunks = 0;
      window.severeBreakCount = 0;
      window.lastGoodAudioTime = 0;
      
      // Clear any pending timeouts and intervals
      if (window.noAudioTimeout) {
        clearTimeout(window.noAudioTimeout);
        window.noAudioTimeout = null;
      }
      
      if (window.noChunksTimeout) {
        clearTimeout(window.noChunksTimeout);
        window.noChunksTimeout = null;
      }
      
      if (window.autoRecoveryInterval) {
        clearInterval(window.autoRecoveryInterval);
        window.autoRecoveryInterval = null;
      }
      
      // Update UI
      connectBtn.style.display = 'inline-block';
      stopBtn.style.display = 'none';
      audioSection.style.display = 'none';
      playBtn.textContent = '‚ñ∂Ô∏è';
      
      updateStatus('‚èπÔ∏è Radio stopped');
      connectionStat.textContent = '‚ùå';
      
      console.log('‚èπÔ∏è PCM radio streaming stopped');
    }

    // Update status display
    function updateStatus(message, type = '') {
      statusDisplay.textContent = message;
      statusDisplay.className = 'status';
      if (type) {
        statusDisplay.classList.add(type);
      }
    }

    // Format bytes for display
    function formatBytes(bytes) {
      if (bytes === 0) return '0 B';
      const k = 1024;
      const sizes = ['B', 'KB', 'MB'];
      const i = Math.floor(Math.log(bytes) / Math.log(k));
      return Math.round(bytes / Math.pow(k, i)) + ' ' + sizes[i];
    }

    // Cleanup on page unload
    window.addEventListener('beforeunload', () => {
      if (websocket) websocket.close();
      if (audioContext) audioContext.close();
      if (window.wakeLock) window.wakeLock.release();
      if (window.backgroundKeepAlive) clearInterval(window.backgroundKeepAlive);
    });
    
    // Handle page visibility changes for background audio
    document.addEventListener('visibilitychange', function() {
      if (document.hidden) {
        // User switched to another tab/window
        window.userPageHidden = true;
        console.log('üì± User switched AWAY from radio page - enabling background audio');
        
        if (isPlaying && isStreaming) {
          startBackgroundAudioMode();
        }
        
      } else {
        // User returned to the radio tab
        window.userPageHidden = false;
        console.log('üì± User RETURNED to radio page - optimizing audio');
        
        if (window.backgroundAudioActive) {
          stopBackgroundAudioMode();
          resumeForegroundAudio();
        }
      }
    });
    
    // Start background audio mode with aggressive continuation
    async function startBackgroundAudioMode() {
      console.log('üîÑ Starting AGGRESSIVE background audio mode...');
      window.backgroundAudioActive = true;
      
      // Request wake lock to prevent audio interruption
      try {
        if ('wakeLock' in navigator) {
          window.wakeLock = await navigator.wakeLock.request('screen');
          console.log('üîí Wake lock acquired for background audio');
        }
      } catch (error) {
        console.log('‚ö†Ô∏è Wake lock not available:', error.message);
      }
      
      // Aggressive keep-alive interval to maintain audio context
      window.backgroundKeepAlive = setInterval(() => {
        if (isPlaying && audioContext && audioContext.state === 'suspended') {
          console.log('üîÑ Resuming suspended audio context in background');
          audioContext.resume().catch(e => console.log('Resume failed:', e));
        }
        
        // Force audio scheduling to continue
        if (isPlaying && audioQueue.length > 0) {
          const currentTime = audioContext.currentTime;
          if (nextNoteTime < currentTime - 0.1) {
            console.log('üîÑ Background audio timing correction');
            nextNoteTime = currentTime + 0.05;
          }
        }
        
        // Log background audio status
        console.log(`üéµ Background audio: queue=${audioQueue.length}, playing=${isPlaying}, context=${audioContext?.state}`);
        
      }, 500); // Check every 500ms for aggressive background support
      
      updateStatus('üéß Background audio active - radio playing in background', 'success');
      backgroundStatus.style.display = 'block';
    }
    
    // Stop background audio mode
    function stopBackgroundAudioMode() {
      console.log('‚èπÔ∏è Stopping background audio mode...');
      window.backgroundAudioActive = false;
      
      // Release wake lock
      if (window.wakeLock) {
        window.wakeLock.release();
        window.wakeLock = null;
        console.log('üîì Wake lock released');
      }
      
      // Stop keep-alive interval
      if (window.backgroundKeepAlive) {
        clearInterval(window.backgroundKeepAlive);
        window.backgroundKeepAlive = null;
      }
      
      backgroundStatus.style.display = 'none';
    }
    
    // Resume foreground audio with optimization
    async function resumeForegroundAudio() {
      console.log('üîÑ Resuming foreground audio...');
      
      // Ensure audio context is running
      if (audioContext && audioContext.state !== 'running') {
        try {
          await audioContext.resume();
          console.log('‚úÖ Audio context resumed for foreground');
        } catch (error) {
          console.error('‚ùå Failed to resume audio context:', error);
        }
      }
      
      // Optimize audio queue for smooth resumption
      if (audioQueue.length > 8) {
        console.log('üóëÔ∏è Optimizing audio queue for foreground return');
        audioQueue = audioQueue.slice(-4); // Keep only recent audio for smooth resumption
      }
      
      // Reset timing for immediate audio
      if (isPlaying && audioContext) {
        nextNoteTime = audioContext.currentTime + 0.02;
        console.log('‚è∞ Audio timing reset for foreground return');
      }
      
      updateStatus('üî¥ LIVE - Resumed foreground audio!', 'success');
    }

    // Initialize
    window.addEventListener('load', () => {
      console.log('üìª HD PCM FM Radio Player loaded');
    });
  </script>
</body>
</html>
