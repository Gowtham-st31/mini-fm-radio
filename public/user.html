
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>FM Radio - PCM Player</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      text-align: center;
      padding: 20px;
      margin: 0;
      min-height: 100vh;
    }
    
    .container {
      max-width: 600px;
      margin: 0 auto;
      background: rgba(255, 255, 255, 0.1);
      padding: 40px;
      border-radius: 20px;
      backdrop-filter: blur(10px);
    }
    
    h1 {
      color: #ff6b35;
      margin-bottom: 30px;
      font-size: 2.5rem;
    }
    
    .status {
      padding: 20px;
      margin: 20px 0;
      background: rgba(0, 0, 0, 0.3);
      border-radius: 15px;
      font-size: 1.2rem;
      min-height: 60px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    .btn {
      background: linear-gradient(45deg, #ff6b35, #f7931e);
      color: white;
      border: none;
      padding: 18px 35px;
      font-size: 1.2rem;
      border-radius: 30px;
      cursor: pointer;
      margin: 15px;
      min-width: 200px;
      font-weight: 600;
    }
    
    .btn:disabled {
      background: #666;
      cursor: not-allowed;
    }
    
    .btn.stop {
      background: linear-gradient(45deg, #e74c3c, #c0392b);
    }
    
    .audio-section {
      margin: 30px 0;
      padding: 25px;
      background: rgba(0, 0, 0, 0.2);
      border-radius: 15px;
      display: none;
    }
    
    .play-controls {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 25px;
      margin: 25px 0;
    }
    
    .play-btn {
      background: linear-gradient(45deg, #27ae60, #2ecc71);
      color: white;
      border: none;
      width: 80px;
      height: 80px;
      border-radius: 50%;
      font-size: 2rem;
      cursor: pointer;
    }
    
    .volume-control {
      display: flex;
      align-items: center;
      gap: 10px;
    }
    
    .volume-slider {
      width: 120px;
      height: 6px;
      border-radius: 3px;
      background: rgba(255, 255, 255, 0.3);
      outline: none;
    }
    
    .stats {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 15px;
      margin: 25px 0;
    }
    
    .stat {
      background: rgba(0, 0, 0, 0.3);
      padding: 20px 15px;
      border-radius: 12px;
      text-align: center;
    }
    
    .stat-value {
      font-size: 1.8rem;
      font-weight: bold;
      color: #ff6b35;
      margin-bottom: 8px;
    }
    
    .stat-label {
      font-size: 0.9rem;
      opacity: 0.8;
    }
    
    .success {
      background: rgba(46, 204, 113, 0.3) !important;
      color: #2ecc71 !important;
    }
    
    .error {
      background: rgba(231, 76, 60, 0.3) !important;
      color: #e74c3c !important;
    }
    
    .streaming {
      background: rgba(52, 152, 219, 0.3) !important;
      color: #3498db !important;
    }
    
    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.6; }
    }
    
    .streaming {
      animation: pulse 2s ease-in-out infinite;
    }
    
    .visualizer {
      margin: 25px 0;
      height: 60px;
      background: rgba(0, 0, 0, 0.3);
      border-radius: 10px;
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: hidden;
    }
    
    .wave {
      width: 3px;
      background: linear-gradient(to top, #ff6b35, #f7931e);
      margin: 0 1px;
      border-radius: 1px;
      transition: height 0.1s ease;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>üìª FM Radio - PCM Player</h1>
    
    <div class="status" id="statusDisplay">
      üéß Ready for live radio
    </div>
    
    <div>
      <button class="btn" id="connectBtn" onclick="startRadio()">
        üéµ Connect to Radio
      </button>
      <button class="btn stop" id="stopBtn" onclick="stopRadio()" style="display: none;">
        ‚èπÔ∏è Stop Radio
      </button>
    </div>
    
    <div class="audio-section" id="audioSection">
      <div class="play-controls">
        <button class="play-btn" id="playBtn" onclick="toggleAudio()">
          ‚ñ∂Ô∏è
        </button>
        
        <div class="volume-control">
          <span>üîä</span>
          <input type="range" id="volumeSlider" class="volume-slider" 
                 min="0" max="100" value="70" onchange="setVolume(this.value)">
          <span id="volumeDisplay">70%</span>
        </div>
      </div>
      
      <div class="visualizer" id="visualizer"></div>
    </div>
    
    <div class="stats">
      <div class="stat">
        <div class="stat-value" id="connectionStat">‚ùå</div>
        <div class="stat-label">Connection</div>
      </div>
      <div class="stat">
        <div class="stat-value" id="chunkStat">0</div>
        <div class="stat-label">Chunks</div>
      </div>
      <div class="stat">
        <div class="stat-value" id="dataStat">0 KB</div>
        <div class="stat-label">Data</div>
      </div>
      <div class="stat">
        <div class="stat-value" id="bufferStat">0%</div>
        <div class="stat-label">Buffer</div>
      </div>
    </div>
  </div>

  <script>
    // Audio variables
    let websocket = null;
    let audioContext = null;
    let gainNode = null;
    let isStreaming = false;
    let isPlaying = false;
    let chunkCount = 0;
    let totalBytes = 0;
    
    // Simple continuous audio approach - using AudioWorklet for seamless playback
    let audioQueue = [];
    let audioElement = null;
    let mediaSource = null;
    let sourceBuffer = null;
    let sampleRate = 48000;
    
    // DOM elements
    const statusDisplay = document.getElementById('statusDisplay');
    const connectBtn = document.getElementById('connectBtn');
    const stopBtn = document.getElementById('stopBtn');
    const audioSection = document.getElementById('audioSection');
    const playBtn = document.getElementById('playBtn');
    const volumeSlider = document.getElementById('volumeSlider');
    const volumeDisplay = document.getElementById('volumeDisplay');
    const visualizer = document.getElementById('visualizer');
    const connectionStat = document.getElementById('connectionStat');
    const chunkStat = document.getElementById('chunkStat');
    const dataStat = document.getElementById('dataStat');
    const bufferStat = document.getElementById('bufferStat');

    // Initialize visualizer
    function createVisualizer() {
      visualizer.innerHTML = '';
      for (let i = 0; i < 40; i++) {
        const wave = document.createElement('div');
        wave.className = 'wave';
        wave.style.height = '5px';
        visualizer.appendChild(wave);
      }
    }

    // Animate visualizer based on audio data
    function animateVisualizer(audioData = null) {
      const waves = visualizer.querySelectorAll('.wave');
      
      if (audioData && isPlaying) {
        // Use actual audio data for visualization
        const step = Math.floor(audioData.length / waves.length);
        waves.forEach((wave, index) => {
          const dataIndex = index * step;
          const amplitude = Math.abs(audioData[dataIndex] || 0);
          const height = Math.min(amplitude * 60 + 5, 50);
          wave.style.height = height + 'px';
        });
      } else {
        // Random animation when not playing
        waves.forEach(wave => {
          const height = Math.random() * (isPlaying ? 30 : 10) + 5;
          wave.style.height = height + 'px';
          wave.style.opacity = isPlaying ? 0.9 : 0.3;
        });
      }
    }

    // Start radio
    async function startRadio() {
      try {
        updateStatus('üîß Initializing audio system...', 'streaming');
        
        // Create simple audio element approach
        audioElement = document.createElement('audio');
        audioElement.controls = false;
        audioElement.autoplay = true;
        audioElement.volume = 0.7;
        
        updateStatus('üåê Connecting to radio server...', 'streaming');
        
        // Connect to WebSocket
        await connectWebSocket();
        
        // Initialize streaming
        isStreaming = true;
        chunkCount = 0;
        totalBytes = 0;
        audioQueue = [];
        
        // Update UI
        connectBtn.style.display = 'none';
        stopBtn.style.display = 'inline-block';
        audioSection.style.display = 'block';
        
        createVisualizer();
        setInterval(() => animateVisualizer(), 100);
        
        updateStatus('‚úÖ Connected! Receiving audio...', 'success');
        
        console.log('üéß Simple audio streaming started');
        
      } catch (error) {
        console.error('‚ùå Failed to start radio:', error);
        updateStatus('‚ùå Failed to start: ' + error.message, 'error');
      }
    }

    // Connect to WebSocket
    function connectWebSocket() {
      return new Promise((resolve, reject) => {
        try {
          const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
          const wsUrl = protocol + '//' + window.location.host;
          
          console.log('üîó Connecting to:', wsUrl);
          
          websocket = new WebSocket(wsUrl);
          websocket.binaryType = 'arraybuffer';
          
          websocket.onopen = () => {
            console.log('‚úÖ WebSocket connected');
            connectionStat.textContent = '‚úÖ';
            resolve();
          };
          
          websocket.onmessage = async (event) => {
            if (isStreaming) {
              await handlePCMData(event.data);
            }
          };
          
          websocket.onclose = () => {
            console.log('‚ùå WebSocket disconnected');
            updateStatus('‚ùå Connection lost', 'error');
            connectionStat.textContent = '‚ùå';
          };
          
          websocket.onerror = (error) => {
            console.error('‚ùå WebSocket error:', error);
            updateStatus('‚ùå Connection failed', 'error');
            connectionStat.textContent = '‚ùå';
            reject(new Error('WebSocket connection failed'));
          };
          
        } catch (error) {
          console.error('‚ùå Failed to create WebSocket:', error);
          reject(error);
        }
      });
    }

    // Handle incoming PCM data - convert to WAV and play directly
    async function handlePCMData(arrayBuffer) {
      chunkCount++;
      totalBytes += arrayBuffer.byteLength;
      
      // Update stats
      chunkStat.textContent = chunkCount;
      dataStat.textContent = formatBytes(totalBytes);
      bufferStat.textContent = '100%'; // Always ready with direct playback
      
      console.log(`üì° Received PCM chunk ${chunkCount}: ${arrayBuffer.byteLength} bytes`);
      
      // Convert PCM to WAV blob for immediate playback
      if (isPlaying && audioElement) {
        try {
          const wavBlob = createWavBlob(arrayBuffer);
          const audioUrl = URL.createObjectURL(wavBlob);
          
          // Play immediately
          audioElement.src = audioUrl;
          audioElement.play().catch(e => {
            console.log('‚ö†Ô∏è Playback issue:', e);
          });
          
          // Cleanup after playback
          setTimeout(() => {
            URL.revokeObjectURL(audioUrl);
          }, 2000);
          
          // Animate visualizer
          const pcmData = new Int16Array(arrayBuffer);
          const floatData = new Float32Array(pcmData.length);
          for (let i = 0; i < pcmData.length; i++) {
            floatData[i] = pcmData[i] / 32768.0;
          }
          animateVisualizer(floatData);
          
        } catch (error) {
          console.error('‚ùå Audio conversion error:', error);
        }
      }
      
      // Auto-enable play after receiving some data
      if (chunkCount === 2 && !isPlaying) {
        updateStatus('üéµ Ready! Click ‚ñ∂Ô∏è to hear audio', 'success');
      }
    }

    // Create WAV blob from PCM data
    function createWavBlob(pcmBuffer) {
      const pcmData = new Int16Array(pcmBuffer);
      const length = pcmData.length;
      const buffer = new ArrayBuffer(44 + length * 2);
      const view = new DataView(buffer);
      
      // WAV header
      const writeString = (offset, string) => {
        for (let i = 0; i < string.length; i++) {
          view.setUint8(offset + i, string.charCodeAt(i));
        }
      };
      
      writeString(0, 'RIFF');
      view.setUint32(4, 36 + length * 2, true);
      writeString(8, 'WAVE');
      writeString(12, 'fmt ');
      view.setUint32(16, 16, true);
      view.setUint16(20, 1, true);
      view.setUint16(22, 1, true); // Mono
      view.setUint32(24, sampleRate, true);
      view.setUint32(28, sampleRate * 2, true);
      view.setUint16(32, 2, true);
      view.setUint16(34, 16, true);
      writeString(36, 'data');
      view.setUint32(40, length * 2, true);
      
      // Copy PCM data
      const pcmView = new Int16Array(buffer, 44);
      pcmView.set(pcmData);
      
      return new Blob([buffer], { type: 'audio/wav' });
    }

    // Toggle audio playback
    async function toggleAudio() {
      if (!isStreaming) {
        updateStatus('‚ùå Please connect to radio first', 'error');
        return;
      }
      
      try {
        if (isPlaying) {
          // Stop playing
          isPlaying = false;
          playBtn.textContent = '‚ñ∂Ô∏è';
          updateStatus('‚è∏Ô∏è Audio paused', 'success');
          
          if (audioElement) {
            audioElement.pause();
          }
          
        } else {
          // Start playing
          isPlaying = true;
          playBtn.textContent = '‚è∏Ô∏è';
          updateStatus('üéµ Playing live radio!', 'success');
        }
        
      } catch (error) {
        console.error('‚ùå Audio toggle error:', error);
        updateStatus('‚ùå Audio error: ' + error.message, 'error');
      }
    }

    // Set volume
    function setVolume(value) {
      const volume = value / 100;
      if (audioElement) {
        audioElement.volume = volume;
      }
      volumeDisplay.textContent = value + '%';
    }

    // Set volume
    function setVolume(value) {
      const volume = value / 100;
      if (audioElement) {
        audioElement.volume = volume;
      }
      volumeDisplay.textContent = value + '%';
    }

    // Stop radio
    function stopRadio() {
      isStreaming = false;
      isPlaying = false;
      
      // Stop and cleanup audio element
      if (audioElement) {
        audioElement.pause();
        audioElement.src = '';
        audioElement = null;
      }
      
      // Clear buffer
      audioQueue = [];
      
      // Close WebSocket
      if (websocket) {
        websocket.close();
        websocket = null;
      }
      
      // Reset variables
      chunkCount = 0;
      totalBytes = 0;
      
      // Update UI
      connectBtn.style.display = 'inline-block';
      stopBtn.style.display = 'none';
      audioSection.style.display = 'none';
      playBtn.textContent = '‚ñ∂Ô∏è';
      
      updateStatus('‚èπÔ∏è Radio stopped');
      connectionStat.textContent = '‚ùå';
      
      console.log('‚èπÔ∏è Simple radio streaming stopped');
    }

    // Update status display
    function updateStatus(message, type = '') {
      statusDisplay.textContent = message;
      statusDisplay.className = 'status';
      if (type) {
        statusDisplay.classList.add(type);
      }
    }

    // Format bytes for display
    function formatBytes(bytes) {
      if (bytes === 0) return '0 B';
      const k = 1024;
      const sizes = ['B', 'KB', 'MB'];
      const i = Math.floor(Math.log(bytes) / Math.log(k));
      return Math.round(bytes / Math.pow(k, i)) + ' ' + sizes[i];
    }

    // Cleanup on page unload
    window.addEventListener('beforeunload', () => {
      if (websocket) websocket.close();
      if (audioContext) audioContext.close();
    });

    // Initialize
    window.addEventListener('load', () => {
      console.log('üìª PCM FM Radio Player loaded');
    });
  </script>
</body>
</html>
